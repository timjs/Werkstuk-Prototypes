\chapter{Natuurlijke Semantiek}

\section{Expressies}

Expressies zijn syntactische elementen die zonder de \emph{toestand} van het programma te wijzigen \emph{geëvalueerd} worden tot een waarde $v \in \VV$. 
Bij het evalueren van expressies maken wij gebruik van een notatie met dubbele rechte haken. Hiermee geven we aan dat alles tussen deze dubbele haken \emph{syntaxis} is. Zo scheiden we we onze taal van de wiskunde. Bij het evalueren hebben we wel meer informatie nodig dan alleen de expressie zelf. De geheugens $\ms$ en $\mo$ voor bereiken en objecten worden gebruikt om de \emph{toestand} van het programma mee te geven. Daarnaast leggen het huidige bereik $\sigma$ en het huidige object $\tau$ vast in welke \emph{omgeving} de evaluatie plaats vindt. Deze extra informatie noteren we als subscript bij de haken. Evaluaties zijn dus van de vorm
%
\begin{equation*}
  \Express{E}{\ms,\mo,\sigma,\tau} = v.
\end{equation*}
%
De signatuur van de functie $\Express{\;}{}$ is dan
\begin{equation*}
  \Express{\;}{} : \Expr \times \MMs \times \MMo \times \LLs \times \LLo \to \VV \\
\end{equation*}

Ook definiëren we een \emph{uitgebreide} semantische functie voor syntactische elementen uit \MaybeExprs. Deze zijn te onderscheiden van de \emph{gewone} expressies door de superscript $\text{M}$ naast de haken. Merk op dat in dit geval het resultaat niet een enkele waarde is, maar een lijst van waardes.
\begin{equation*}
  \Express[M]{\;}{} : \MaybeExprs \times \MMs \times \MMo \times \LLs \times \LLo \to \VV_{\langle\rangle}
\end{equation*}

Voor Boolse expressies geldt hetzelfde, maar deze evalueren tot de verzameling $\{\bT, \bF\}$.
Hierbij gebruiken wij het symbool $\bT$ voor \emph{waar} en $\bF$ voor \emph{onwaar}.
Om aan te geven dat we te maken hebben met de evaluatie van Boolse expressies noteren we een superscript $\text{B}$ bij de haken.
%
\begin{equation*}
  \Express[B]{\;}{} : \BExpr \times \MMs \times \MMo \times \LLs \times \LLo \to \{ \bT, \bF \} \\
\end{equation*}

Het evalueren van getallen beschouwen we voor het gemak apart. Dit is simpelweg een functie van de syntactische verzameling \Num\ naar $\ZZ$.
%
\begin{equation*}
  \Express[Z]{\;}{} : \Num \to \ZZ \\
\end{equation*}

%Voor elk van deze drie soorten expressies definiëren we semantische functies die deze evaluatie formeel maken. De signaturen van de vier functies zijn:

\subsection{Getal expressies}

%TODO: Gaan wij nou getallen net zo definieeren als Nielsen & Nielsen?
Laten we beginnen met het evalueren van gehele getallen zoals gedefinieerd in §\ref{sec:formeletaal}.
%
\begin{align*}
  \Express[Z]{0}{} &= 0 &
  \Express[Z]{n 0}{} &= 2 \cdot \Express[Z]{n}{} \\
  \Express[Z]{1}{} &= 1 &
  \Express[Z]{n 1}{} &= 2 \cdot \Express[Z]{n}{} + 1
\end{align*}

\subsection{Gewone expressies}

De eerste type expressie die we tegenkomen in de definitie van §\ref{sec:formeletaal} zijn de getallen. Deze hebben we hierboven al gedefinieerd met de gespecialiseerde functie $\Express[Z]{\;}{}$. Hier kunnen we nu mooi gebruik van maken.
%
\begin{equation*}
  \Express{n}{\ms,\mo,\sigma,\tau} = \Express[Z]{n}{}
  \tag*{[num]}
\end{equation*}
%
Daarnaast hebben we natuurlijk de aritmetische expressies van de form $e_1 \circ e_2$. Hierbij is $\circ$ een van de operatoren $+$, $-$ of $\times$. Aritmetische expressies worden geëvalueerd door eerst beide deelexpressies te evalueren tot getallen en hier vervolgens de betreffende operator op lost te laten.
%
\begin{gather*}
  \Express{e_1 \circ e_2}{\ms,\mo,\sigma,\tau} = n_1 \circ n_2
  \tag*{[op]} \\
  \Desdas{
    \Desda[desda]{n_1 = \Express{e_1}{\ms,\mo,\sigma,\tau} \in \ZZ}
    \Desda{n_2 = \Express{e_2}{\ms,\mo,\sigma,\tau} \in \ZZ}
    \Desda{(\circ) \textbf{ één van: } +, -, \times}
  }
\end{gather*}

Bij de evaluatie van een \Path-expressie moeten we rekening houden met twee dingen. Ten eerste is een pad gedefinieerd als een losse \Id\ of een aaneenschakeling van de vorm $\Id.\Path$. Ten tweede kan de eerste \Id\ die we tegenkomen een verwijzing zijn naar het huidige object: $\THIS$. Het combineren van deze twee aandachtspunten levert ons vier verschillende gevallen op die we onderscheiden met \emph{pattern matching}.

Het eenvoudigste geval is wanneer we te maken hebben met één \Id\ die gelijk is aan $\THIS$. We retourneren simpelweg de locatie van het huidige object $\tau$.
%
\begin{equation*}
  \Express{\THIS}{\ms,\mo,\sigma,\tau} = \tau
  \tag*{[this]}
\end{equation*}
%
Wanneer we te maken hebben met een willekeurige andere \Id\ $i$, schakelen we de hulp in van de functie $\Finds$. Zoals beschreven in §\ref{sec:hulpfuncties} zoekt deze het bereik $\sigma'$ op waarin $i$ gedefinieerd is (mogelijk gelijk aan $\sigma$ zelf). Vervolgens zoeken we de waarde van $i$ op in de bindingen van dit bereik.
%
\begin{gather*}
  %\Express{i}{\ms,\mo,\sigma,\tau} = \big( \Finds(\ms, \sigma, i) \big)(i)
  % T: Volgens mij moet deze zo:
  \Express{i}{\ms,\mo,\sigma,\tau} = v
  \tag*{[identifier]}\label{rul:identifier} \\
  \Desdas{
    \Desda[desda]{\Finds(\ms, \sigma, i) = \sigma'}
    \Desda{b_{\ms(\sigma')}(i) = v}
  }
\end{gather*}

De volgende stap is het geval waarin we te maken hebben met een \Path\ $p$ in plaats van een losse \Id. Hier schakelen we als eerste $\Trav$ in, die het pad doorloopt en ons het laatst ontdekte object $\omega'$ en de laatste \Id\ $j$ teruggeeft. Hierna kunnen we op zoek naar het prototype $\omega''$ waarin $j$ is gedefinieerd met hulp van $\Findp$. Tot slot zoeken we de waarde van $j$ op in de bindingen van dit prototype. Wanneer het eerste onderdeel van het \Path\ begint met $\THIS$ doorlopen we het pad beginnende bij het huidige object $\tau$.
%
\begin{gather*}
  \Express{\THIS.p}{\ms,\mo,\sigma,\tau} = v
  \tag*{[this.path]} \\
  \Desdas{
    \Desda[desda]{\Trav(\mo, \tau, p) = (\omega' \in \LLo, j)}
    \Desda{\Findp(\omega',j) = \omega''}
    \Desda{b_{\mo(\omega'')}(j) = v}
  }
\end{gather*}
%
Als dit niet het geval is, moeten we eerst op zoek naar het object in $i$. Hier kunnen we handig gebruik maken van de regel~\ref{rul:identifier} hierboven.
%
\begin{gather*}
  \Express{i.p}{\ms,\mo,\sigma,\tau} = v
  \tag*{[path]} \\
  \Desdas{
    \Desda[desda]{\Express{i}{\ms,\mo,\sigma,\tau} = \omega \in \LLo}
    \Desda{\Trav(\mo, \omega, p) = (\omega' \in \LLo, j)}
    \Desda{\Findp(\omega',j) = \omega''}
    \Desda{b_{\mo(\omega'')}(j) = v}
  }
\end{gather*}
%
Merk op dat wanneer $\Express{i}{\ms,\mo,\sigma,\tau}$ geen $\omega\in\LLo$ oplevert bovenstaande niet gedefinieerd is en $\Express{i.p}{}$ dus niet geëvalueerd kan worden.

De laatste familie van expressies zijn de functies. Hier maken we onderscheid tussen functies \emph{met} teruggeefwaarde en \emph{zonder} teruggeefwaarde. In §\ref{sec:functies} is besproken hoe wij functies opbouwen in ons model. Onderstaande expressies creëren zo'n functie.
%
\begin{equation}
  \Express{\FUN (i^*) \: \{S\}}{\ms,\mo,\sigma,\tau} = (S, \textsc{Ids}(i^*), \nil, \sigma)
  \tag*{[function]}\label{rul:function}
\end{equation}
%
\begin{equation}
  \Express{\FUN (i^*) \RETURNS j \: \{S\}}{\ms,\mo,\sigma,\tau} = (S, \textsc{Ids}(i^*), j, \sigma)
  \tag*{[function returns]}\label{rul:functionreturns}
\end{equation}
%
We zien dat we alle benodigde gegevens uit de expressie overnemen en opslaan in een $f\in\FF$. Het enige verschil tussen de regels~\ref{rul:function} en \ref{rul:functionreturns} is het overnemen van de teruggeef-\Id\ $j$ in de quadrupel.

\subsection{Boolse expressies}

Het evalueren van boolse expressies is, in vergelijking met de gewone expressies hierboven, redelijk eenvoudig. Allereerst evalueren de sleuterwoorden $\TRUE$ en $\FALSE$ simpelweg naar $\bT$ en $\bF$:
%
\begin{equation}
  \Express[B]{\TRUE}{\ms,\mo,\sigma,\tau} = \bT
  \tag*{[true]}
\end{equation}
%
\begin{equation}
  \Express[B]{\FALSE}{\ms,\mo,\sigma,\tau} = \bF
  \tag*{[false]}
\end{equation}

Een negatie is natuurlijk eenvoudig te definiëren in termen van bovenstaande.
%
\begin{equation}
  \Express[B]{\NOT b}{\ms,\mo,\sigma,\tau}
  = \begin{cases}
    \bT & \textbf{if } \Express[B]{b}{\ms,\mo,\sigma,\tau} = \bF \\
    \bF & \textbf{anders}
  \end{cases}
  \tag*{[not]}
\end{equation}

Daarnaast kunnen we Boolse expressies combineren met een conjunctie of disjunctie. We gebruiken dezelfde truc als hierboven en evalueren $b_1$ en $b_2$ eerst los.
%
\begin{equation}
  \Express[B]{b_1 \AND b_2}{\ms,\mo,\sigma,\tau}
  = \begin{cases}
    \bT & \textbf{if } \Express[B]{b_1}{\ms,\mo,\sigma,\tau} = \Express[B]{b_2}{\ms,\mo,\sigma,\tau} = \bT \\
    \bF & \textbf{anders}
  \end{cases}
  \tag*{[and]}
\end{equation}
%
\begin{equation}
  \Express[B]{b_1 \OR b_2}{\ms,\mo,\sigma,\tau}
  = \begin{cases}
    \bF & \textbf{if } \Express[B]{b_1}{\ms,\mo,\sigma,\tau} = \Express[B]{b_2}{\ms,\mo,\sigma,\tau} = \bF \\
    \bT & \textbf{anders}
  \end{cases}
  \tag*{[or]}
\end{equation}

%TODO: Hier maken we ook geen onderscheid tussen taal en wiskunde!
Tot slot bevat onze taal een methode om tests uit te voeren op getallen. Hier nemen we de relaties over uit de taal en plaatsen ze in de wiskundige context.
%
\begin{gather*}
  \Express[B]{e_1 \sim e_2}{\ms,\mo,\sigma,\tau} =
  n_1 \sim n_2
  \tag*{[relation]} \\
  \Desdas{
    \Desda[waarbij]{n_1 = \Express{e_1}{\ms,\mo,\sigma,\tau} \in \ZZ}
    \Desda{n_2 = \Express{e_2}{\ms,\mo,\sigma,\tau} \in \ZZ}
    \Desda{(\sim) \textbf{ één van: } =, \neq, <, \le, >, \ge}
  }
\end{gather*}

%TODO: We doen niets meer met MaybeExpressions, die moet hier nog...

\section{Statements}

\subsection{Basis}

Het evalueren van een statement noteren we met dubbele vishaken. Net als bij expressies hebben we ook hier extra informatie nodig in de vorm van $\ms$, $\mo$, $\sigma$ en $\tau$. Ook hier noteren we deze als subscript bij de haken. Onze uitspraken zijn dan van de vorm:
%
\begin{equation*}
  \Config{S}{\ms,\mo,\sigma,\tau} \longrightarrow (\ms',\mo').
\end{equation*}
%
Hiermee bedoelen we dat
%
\begin{equation*}
  \big(\,(S,\ms,\mo,\sigma,\tau), (\ms',\mo')\,\big) \in (\longrightarrow),
\end{equation*}
%
waarbij $\longrightarrow$ de volgende signatuur heeft 
%
\begin{equation*}
  (\longrightarrow) \subseteq (\Stm \times \MMs \times \MMo \times \LLs \times \LLo) \times (\MMs \times \MMo).
\end{equation*}
%
Deze transitie werkt op een statement $S\in\Stm$ in een toestand $(\ms,\mo)\in(\MMs,\MMo)$. Het resultaat is een nieuwe toestand in de vorm van de twee geheugens $(\ms',\mo')\in(\MMs,\MMo)$.

Laten we beginnen met de simpelste constructie in onze taal, het lege statement $\SKIP$. Deze heeft de vorm van een axioma.
%
\begin{equation*}
  \AxiomC{$
    \Config{\SKIP}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms, \mo)
  $}
  {\DisplayProof}
  \tag*{[skip]}
\end{equation*}
%
$\SKIP$ verandert niets aan de toestand zodat $(\ms',\mo')=(\ms,\mo)$. Voor het samenstellen van statements hebben we een regel nodig.
%
\begin{gather*}
  \AxiomC{$
    \Config{S_1}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo')
  $}
  \AxiomC{$
    \Config{S_2}{\ms', \mo', \sigma, \tau}
    \longrightarrow
    (\ms'', \mo'')
  $}
  \BinaryInfC{$
    \Config{S_1; S_2}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms'', \mo'')
  $}
  {\DisplayProof}
  \tag*{[comp]}
\end{gather*}
%
In dit geval geven we aan dat, wanneer we een een compositie hebben van de statements $S_1$ en $S_2$, we eerst $S_1$ uitvoeren% T: Dit is niet het juiste woord, weten even geen betere...
en daarna $S_2$. Tijdens dit proces ontstaan nieuwe toestanden, waar we natuurlijk rekening mee moeten houden. De geheugens worden dan ook netjes doorgesluisd.

Voor de controlestructuur $\IF$ hebben we twee regels nodig. De eerste is voor het geval dat de \BExpr\ evalueert in \bT, dan moet namelijk het statement van het $\THEN$-deel worden uitgevoerd. Wanneer de \BExpr\ evalueert in \bF\ moet het $\ELSE$-deel worden uitgevoerd.
Er moet dus aan een extra voorwaarde worden voldaan om deze regels toe te mogen passen. Dit zal vaker voorkomen bij de komende deductieregels. We noteren deze extra voorwaarden onder de regel of het axioma.
%Zoals vele axioma's en deductieregels heeft dit axioma een aantal voorwaarden waaraan voldaan moet worden. Deze staan eronder genoteerd, elk op een regel.  
%
\begin{gather*}
  \AxiomC{$
    \Config{S_1}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo')
  $}
  \UnaryInfC{$
    \Config{\IF b \THEN  S_1 \ELSE S_2 }{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo')
  $}
  {\DisplayProof}
  \tag*{[if true]} \\
  \Desdas{
    \Desda[desda]{\Express[B]{b}{\ms, \mo,\sigma,\tau} = \bT}
  }
\end{gather*}
%
en:
%
\begin{gather*}
  \AxiomC{$
    \Config{S_2}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo')
  $}
  \UnaryInfC{$
    \Config{\IF b \THEN S_1 \ELSE S_2 }{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo')
  $}
  {\DisplayProof}
  \tag*{[if false]} \\
  \Desdas{
    \Desda[desda]{\Express[B]{b}{\ms, \mo,\sigma,\tau} = \bF}
  }
\end{gather*}
%
Eenzelfde tactiek passen we toe bij een $\WHILE$-loop.
%
\begin{gather*}
  \AxiomC{$
    \Config{S_1}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms',\mo')
  $}
  \AxiomC{$
    \Config{\WHILE b \DO S_1 }{\ms', \mo', \sigma, \tau}
    \longrightarrow
    (\ms'',\mo'')
  $}
  \BinaryInfC{$
    \Config{\WHILE b \DO S_1 }{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms'',\mo'')
  $}
  {\DisplayProof}
  \tag*{[while true]} \\
  \Desdas{
    \Desda[desda]{\Express[B]{b}{m,\sigma,\tau} = \bT}
  }
\end{gather*}
%
en:
%
\begin{gather*}
  \AxiomC{$
    \Config{\WHILE b \DO S_1 }{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms, \mo)
  $}
  {\DisplayProof}
  \tag*{[while false]} \\
  \Desdas{
    \Desda[desda]{\Express[B]{b}{\ms,\mo,\sigma,\tau} = \bF}
  }
\end{gather*}

\subsection{Variabelen}

We komen nu bij een interessanter deel van de taal, namelijk het \emph{declareren} van variabelen en het \emph{toekennen} van waarden. In deze sectie gaan we dus alleen de bereiken modificeren. Aan de basis hiervan ligt het declareren van een variabele met $\LOCAL$. We willen in het huidige bereik de eigen bindingen zó aanpassen, dat de \Id\ die we declareren gekoppeld wordt aan $\nil$ (de variabele bevat immers nog geen expliciete waarde). Voordat we dit kunnen doen, moeten we bereik $\sigma$ opzoeken in het geheugen voor bereiken $\ms$ met $\ms(\sigma)$. Vervolgens passen we de binding hiervan aan (zie notatie in §\ref{sec:bereiken} en §\ref{sec:uitbreiden}). Met de verwijzing naar het omliggend bereik $\pi$ doen we niks. Dit paar van uitgebreide bindingen en oud omliggend bereik zetten we terug in het geheugen $\ms$ op plek $\sigma$.
%
\begin{gather*}
  \AxiomC{$
    \Config{\LOCAL i}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo)
  $}
  {\DisplayProof}
  \tag*{[local]} \\
  \Desdas{
    \Desda{\ms' = \ms \surr{ \sigma \mapsto \big(b_{\ms(\sigma)}[i \mapsto \BOT], \pi_{\ms(\sigma)}\big) }}
  }
\end{gather*}
%
Wanneer we daadwerkelijk een waarde aan een variabele willen toekennen, doen we dit met dezelfde aanpassingstechniek als hierboven. Er is echter één groot verschil. Voordat we een waarde aan een variabele kunnen koppelen, moeten we eerst het bereik vinden waarin deze gedeclareerd is. Dit hoeft niet het huidige bereik te zijn en dus zoeken we deze op met de hulpfunctie $\Finds$. Daarnaast moeten we natuurlijk de expressie aan de rechter kant van het is-teken evalueren.
%
\begin{gather*}
  \AxiomC{$
    \Config{i = e}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo)
  $}
  {\DisplayProof}
  \tag*{[assign identifier]} \\
  \Desdas{
    \Desda[desda]{\Express{e}{\ms, \mo, \sigma, \tau} = v}
    \Desda{\sigma' = \Finds(\ms, \sigma, i)}
    \Desda{\ms'= \ms \surr{ \sigma' \mapsto \big(b_{\ms(\sigma')}[ i \mapsto v ], \pi_{\ms(\sigma')}\big) }}
  }
\end{gather*}

\subsection{Objecten}

Bij attributen gaat toekenning net iets anders. We hebben de hulp nodig van andere functies en we moeten rekening houden met het doorlopen van een pad. Daarnaast is er nog het speciale geval dat het eerste deel van het pad $\THIS$ is. Natuurlijk gebeuren al deze aanpassingen in het geheugen voor objecten $\mo$ in plaats van het geheugen voor bereiken $\ms$.
%
\begin{gather*}
  \AxiomC{$
    \Config{\THIS.p = e}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms, \mo')
  $}
  {\DisplayProof}
  \tag*{[assign this.path]} \\
  \Desdas{
    \Desda[desda]{\Express{e}{\ms, \mo, \sigma, \tau} = v}
    \Desda{\Trav(\mo, \tau, p) = (\omega, i)}
    \Desda{\mo'= \mo \surr{ \omega \mapsto \big(b_{\mo(\omega)}[ i \mapsto v ], \pi_{\mo(\omega)}\big) }}
  }
\end{gather*}
%
\begin{gather*}
  \AxiomC{$
    \Config{i.p = e}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo)
  $}
  {\DisplayProof}
  \tag*{[assign path]} \\
  \Desdas{
    \Desda[desda]{\Express{e}{\ms, \mo, \sigma, \tau} = v}
    \Desda{\Express{i}{\ms,\sigma,\tau} = \omega}
    %\Desda{\sigma' = \Finds(\ms, \sigma, i)}
    %\Desda{b_{\ms(\sigma')}(i) = \omega \in \LL}
    \Desda{\Trav(\mo, \omega, p) = (\omega', j)}
    \Desda{\mo'= \mo \surr{ \omega' \mapsto \big(b_{\ms(\omega')}[ j \mapsto v ], \pi_{\ms(\omega')}\big) }}
  }
\end{gather*}

Nu hebben we nog niet bekeken hoe we aangeven dat een variabele een object bevat data. In §\ref{sec:waarden} is uitgebreid besproken dat er een significant verschil is tussen primitieve waarden en data. Toch gaat dit op bijna dezelfde manier als het toekennen van een primitieve waarde. De locatie $\omega$ van een object $o$ kan immers wel op dezelfde manier worden behandeld. Wat moet gebeuren is het aanmaken van een nieuw, leeg object in het geheugen voor objecten. Zo een leeg object heeft de vorm $(\varnothing, \nil)$. De bindingen zijn immers leeg en er is nog geen prototype gedefinieerd. Om een nieuwe plek in het geheugen te vinden, kijken we naar de lengte van het huidge geheugen. Tot slot voegen we het legen object achteraan het geheugen toe.
%
\begin{gather*}
  \AxiomC{$
    \Config{i \OBJECT}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo')
  $}
  {\DisplayProof}
  \tag*{[object]} \\
  \Desdas{
    \Desda[desda]{\Finds(\ms, \sigma, i) = \sigma'}
    \Desda{\omega = |\mo|}
    \Desda{\ms' = \ms \surr{ \sigma' \mapsto \big(b_{\ms(\sigma')}[i\mapsto \omega], \pi_{\ms(\sigma')}\big) }}
    \Desda{\mo' = \mo : (\varnothing,\nil)}
  }
\end{gather*}
%
Het definiëren van een prototype gaat met het $\CLONES$-statement. Hiervoor zoeken we simpelweg de locaties $\omega_i$ en $\omega_j$ van de twee objecten op. Vervolgens zetten we in het geheugen dat het prototype van het object in $\omega_i$ de locatie $\omega_j$ is.
%
\begin{gather*}
  \AxiomC{$
    \Config{i \CLONES j}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms, \mo')
  $}
  {\DisplayProof}
  \tag*{[clones]} \\
  \Desdas{
    \Desda[desda]{\Express{i}{\ms,\mo,\sigma,\tau} = \omega_i \in \LL}
    \Desda{\Express{j}{\ms,\mo,\sigma,\tau} = \omega_j \in \LL}
    \Desda{\mo' = \mo \surr{ \omega_i \mapsto \big(b_{\mo(\omega_i)}, \omega_j\big) }}
  }
\end{gather*}

\subsection{Functies}%TODO
%
\dots Komt nog \dots
%
\begin{gather*}
  \AxiomC{$
    \Config{S_{\!f}}{\ms', \mo, \sigma_{\!f\text{new}}, \omega'}
    \longrightarrow
    (\ms'', \mo'')
  $}
  \UnaryInfC{$
    \Config{i.s(e^*)}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms'', \mo'')
  $}
  {\DisplayProof}
  \tag*{[call]} \\
  \Desdas{
    \Desda{\sigma_\text{def} = \Finds(\ms, \sigma, i)}
    \Desda{b_{\ms(\sigma_\text{def})}(i) = \omega \in \LL}
    \Desda{\Trav(\mo, \omega, s) = (\omega', j)}
    \Desda{(S_{\!f}, I_{\!f}, i_{\!f}, \sigma_{\!f\text{def}}) = f = b_{\mo(\omega')}(j)}
    \Desda{\sigma_{\!f\text{new}} = \Nexts(\ms)}
    \Desda{\ms' = \ms\surr{ \sigma_{\!f\text{new}} \mapsto \big(\Surr{e^*}^*_{\ms,\sigma,\tau}(I_{\!f}), \sigma_{\!f\text{def}}\big) }}
  }
\end{gather*}

%\section*{Extra}

%Deze teksten zijn vooral bedoeld als “tekstvlees” (lorem ipsum's). We zullen axioma's en deductieregels introduceren waarmee we de relatie $(\longrightarrow)$ definiëren, die de volgende signatuur heeft:

%$$ (\longrightarrow) \subseteq (\Stm \times \MM \times \LL \times \LL) \times \MM $$

%Wanneer we een uitspraak doen van de vorm:

%$$ \Config{S}{m,\sigma,\tau} \longrightarrow m' $$

%..dan bedoelen we daarmee dat:

%$$ \big(\,(S,m,\sigma,\tau), m'\,\big) \in (\longrightarrow) $$

%Deze uitspraak moet je lezen als: “In de toestand met geheugen $m$, bereik $\sigma$ en \emph{this} object $\tau$, termineert het statement $S$, waarbij het resultaat-geheugen $m'$ is.”
%
%Een van deze axioma's [object], heeft betrekking tot de productieregel in de grammatica die de $\OBJECT$ “literal” introduceert.
%
%Wanneer bij een dergelijke opsomming van voorwaarden een nieuwe variabele wordt geïntroduceerd zoals hierboven, met de volgende vorm: $\textbf{desda } \square = \theta \dots$; dan moet deze gelezen worden als: $\textbf{desda } \exists_\theta \surr{ \square = \theta \dots }$.

% vim: syn=latex spell spl=nl cole=1
