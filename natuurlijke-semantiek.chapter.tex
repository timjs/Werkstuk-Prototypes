\chapter{Natuurlijke Semantiek}

\section{Expressies}

Expressies zijn syntactische elementen die zonder de \emph{toestand} van het programma te wijzigen \emph{geëvalueerd} kunnen worden tot een waarde $v \in \VV$. 
Voor het evalueren definiëren we een aantal semantische functies, en één semantisch predikaat. Met een notatie die gebruik maakt van dubbele rechte haken geven we aan dat hier de stap wordt gemaakt van de \emph{syntaxis} van de taal naar het semantische model. Deze semantische functies (predikaat) nemen als input, naast de expressie die geëvalueerd dient te worden, ook de toestand van het programma: de geheugens $\ms$ en $\mo$ voor bereiken en objecten. Daarnaast leggen het huidige bereik $\sigma$ en het huidige object $\tau$ vast in welke \emph{omgeving} de evaluatie plaats vindt. Deze extra informatie noteren we als subscript bij de haken. Zo zijn evaluaties van ``gewone'' expressies ($\Expr$) zijn van de vorm
%
\begin{equation*}
  \Express{E}{\ms,\mo,\sigma,\tau} = v \in \VV.
\end{equation*}
%
De signatuur van deze functie $\Express{\;}{}$ is dan
%
\begin{equation*}
  \Express{\;}{} : \Expr \times \MMs \times \MMo \times \LLs \times \LLo \to \VV \\
\end{equation*}

Ook definiëren we een \emph{uitgebreide} semantische functie voor syntactische elementen uit \MaybeExprs. Deze functie is nodig wanneer een functie wordt aangeroepen met een willekeurig aantal argumenten. Merk op dat in dit geval het resultaat niet een enkele waarde is, maar een lijst van waarden.
%
\begin{equation*}
  \Express[M]{\;}{} : \MaybeExprs \times \MMs \times \MMo \times \LLs \times \LLo \to \VV_{\langle\rangle}
\end{equation*}

\subsection{Een predikaat voor boolse expressies}

Boolse expressies, die gebruikt worden in de verscheidene loops van de taal, evalueren we niet tot een zekere verzameling. In tegenstelling tot gewone expressies, definiëren we voor boolse expressies een predikaat $\Express[B]{\;}{}$.
%
\begin{equation*}
  \Express[B]{\;}{} \subseteq \BExpr \times \MMs \times \MMo \times \LLs \times \LLo
\end{equation*}
%
De reden voor deze andere aanpak is dat de definitie dan makkelijker leest. We definiëren dat $\Express[B]{b}{\ms,\mo,\sigma,\tau}$, dan en slechts dan als het met de volgende axioma's en deductieregels bewezen kan worden:
%
\begin{align*}
  \Express[B]{\TRUE}{\ms,\mo,\sigma,\tau} & & &
  \frac
    {\neg \Express[B]{b}{\ms,\mo,\sigma,\tau}}
    {\Express[B]{\NOT b}{\ms,\mo,\sigma,\tau}} \\
  \frac
    {\Express[B]{b}{\ms,\mo,\sigma,\tau} \quad \Express[B]{c}{\ms,\mo,\sigma,\tau}}
    {\Express[B]{b \AND c}{\ms,\mo,\sigma,\tau}} & & &
  \frac
    {\Express[B]{b}{\ms,\mo,\sigma,\tau}}
    {\Express[B]{b \OR c}{\ms,\mo,\sigma,\tau}} & & &
  \frac
    {\Express[B]{c}{\ms,\mo,\sigma,\tau}}
    {\Express[B]{b \OR c}{\ms,\mo,\sigma,\tau}}
\end{align*}
\begin{gather*}
  \Express[B]{e_1 \sim e_2}{\ms,\mo,\sigma,\tau} \textbf{ desda } n_1 \sim n_2 \\
  \Desdas{
    \Desda[waarbij]{n_1 = \Express{e_1}{\ms,\mo,\sigma,\tau} \in \ZZ}
    \Desda{n_2 = \Express{e_2}{\ms,\mo,\sigma,\tau} \in \ZZ}
    \Desda{(\sim) \textbf{ één van: } =, \neq, <, \le, >, \ge}
  }
\end{gather*}

\subsection{Evaluatie van gehele getallen}

Het evalueren van getallen ($\Num$) beschouwen we voor het gemak apart, en nemen we later op in de volledige semantische functie voor expressies ($\Expr$).
%
\begin{equation*}
  \Express[Z]{\;}{} : \Num \to \ZZ \\
\end{equation*}
%
Deze functie is als volgt op voor de hand liggend manier gedefinieerd:
%
\begin{align*}
  \Express[Z]{0}{} &= 0 &
  \Express[Z]{n 0}{} &= 2 \cdot \Express[Z]{n}{} \\
  \Express[Z]{1}{} &= 1 &
  \Express[Z]{n 1}{} &= 2 \cdot \Express[Z]{n}{} + 1 \\
  \Express[Z]{-n}{} &= -1 \cdot \Express[Z]{n}{}
\end{align*}

\subsection{Evaluatie van expressies}

De eerste type expressie dat we tegenkomen in de definitie van §\ref{sec:formeletaal} zijn de getallen. Deze hebben we hierboven al gedefinieerd met de gespecialiseerde functie $\Express[Z]{\;}{}$. Hier kunnen we nu mooi gebruik van maken.
%
\begin{equation*}
  \Express{n}{\ms,\mo,\sigma,\tau} = \Express[Z]{n}{}
  \tag*{[num]}
\end{equation*}
%
Daarnaast hebben we natuurlijk de aritmetische expressies van de form $e_1 \circ e_2$. Hierbij is $\circ$ een van de operatoren $+$, $-$ of $\times$. Aritmetische expressies worden geëvalueerd door eerst beide deelexpressies te evalueren tot getallen en hier vervolgens de betreffende operator op lost te laten.
%
\begin{gather*}
  \Express{e_1 \circ e_2}{\ms,\mo,\sigma,\tau} = n_1 \circ n_2
  \tag*{[op]} \\
  \Desdas{
    \Desda[desda]{n_1 = \Express{e_1}{\ms,\mo,\sigma,\tau} \in \ZZ}
    \Desda{n_2 = \Express{e_2}{\ms,\mo,\sigma,\tau} \in \ZZ}
    \Desda{(\circ) \textbf{ één van: } +, -, \times}
  }
\end{gather*}

Bij de evaluatie van een \Path-expressie moeten we rekening houden met twee dingen. Ten eerste is een pad gedefinieerd als een losse \Id\ of een aaneenschakeling van de vorm $\Id.\Path$. Ten tweede kan de eerste \Id\ die we tegenkomen een verwijzing zijn naar het huidige object: $\THIS$. Het combineren van deze twee aandachtspunten levert ons vier verschillende gevallen op die we onderscheiden met \emph{pattern matching}.

Het eenvoudigste geval is wanneer we te maken hebben met één \Id\ die gelijk is aan $\THIS$. We retourneren simpelweg de locatie van het huidige object $\tau$.
%
\begin{equation*}
  \Express{\THIS}{\ms,\mo,\sigma,\tau} = \tau
  \tag*{[this]}
\end{equation*}
%
Wanneer we te maken hebben met een willekeurige andere \Id\ $i$, schakelen we de hulp in van de functie $\Finds$. Zoals beschreven in §\ref{sec:hulpfuncties} zoekt deze het bereik $\sigma'$ op waarin $i$ gedefinieerd is (mogelijk gelijk aan $\sigma$ zelf). Vervolgens zoeken we de waarde van $i$ op in de bindingen van dit bereik.
%
\begin{gather*}
  %\Express{i}{\ms,\mo,\sigma,\tau} = \big( \Finds(\ms, \sigma, i) \big)(i)
  % T: Volgens mij moet deze zo:
  \Express{i}{\ms,\mo,\sigma,\tau} = v
  \tag*{[identifier]}\label{rul:identifier} \\
  \Desdas{
    \Desda[desda]{\Finds(\ms, \sigma, i) = \sigma'}
    \Desda{b_{\ms(\sigma')}(i) = v}
  }
\end{gather*}

De volgende stap is het geval waarin we te maken hebben met een \Path\ $p$ in plaats van een losse \Id. Hier schakelen we als eerste $\Trav$ in, die het pad doorloopt en ons het laatst ontdekte object $\omega'$ en de laatste \Id\ $j$ teruggeeft. Hierna kunnen we op zoek naar het prototype $\omega''$ waarin $j$ is gedefinieerd met hulp van $\Findp$. Tot slot zoeken we de waarde van $j$ op in de bindingen van dit prototype. Wanneer het eerste onderdeel van het \Path\ begint met $\THIS$ doorlopen we het pad beginnende bij het huidige object $\tau$.
%
\begin{gather*}
  \Express{\THIS.p}{\ms,\mo,\sigma,\tau} = v
  \tag*{[this.path]} \\
  \Desdas{
    \Desda[desda]{\Trav(\mo, \tau, p) = (\omega' \in \II, j)}
    \Desda{\Findp(\omega',j) = \omega''}
    \Desda{b_{\mo(\omega'')}(j) = v}
  }
\end{gather*}
%
Als dit niet het geval is, moeten we eerst op zoek naar het object in $i$. Hier kunnen we handig gebruik maken van de regel~\ref{rul:identifier} hierboven.
%
\begin{gather*}
  \Express{i.p}{\ms,\mo,\sigma,\tau} = v
  \tag*{[path]} \\
  \Desdas{
    \Desda[desda]{\Express{i}{\ms,\mo,\sigma,\tau} = \omega \in \II}
    \Desda{\Trav(\mo, \omega, p) = (\omega' \in \II, j)}
    \Desda{\Findp(\omega',j) = \omega''}
    \Desda{b_{\mo(\omega'')}(j) = v}
  }
\end{gather*}
%
Merk op dat wanneer $\Express{i}{\ms,\mo,\sigma,\tau}$ geen $\omega \in \II$ oplevert bovenstaande niet gedefinieerd is en $\Express{i.p}{}$ dus niet geëvalueerd kan worden.

De laatste familie van expressies zijn de functies. Hier maken we onderscheid tussen functies \emph{met} teruggeefwaarde en \emph{zonder} teruggeefwaarde. In §\ref{sec:functies} is besproken hoe wij functies opbouwen in ons model. Onderstaande expressies creëren zo'n functie.
%
\begin{equation}
  \Express{\FUN (i^*) \: \{S\}}{\ms,\mo,\sigma,\tau} = (S, \textsc{Ids}(i^*), \nil, \sigma)
  \tag*{[function]}\label{rul:function}
\end{equation}
%
\begin{equation}
  \Express{\FUN (i^*) \RETURNS j \: \{S\}}{\ms,\mo,\sigma,\tau} = (S, \textsc{Ids}(i^*), j, \sigma)
  \tag*{[function returns]}\label{rul:functionreturns}
\end{equation}
%
We zien dat we alle benodigde gegevens uit de expressie overnemen en opslaan in een $f\in\FF$. Het enige verschil tussen de regels~\ref{rul:function} en \ref{rul:functionreturns} is het overnemen van de teruggeef-\Id\ $j$ in het viertupel.

De volgende voor de hand liggende definitie evalueert een element uit de syntactische verzameling $\MaybeExprs$ to een lijst van waarden.
%
\begin{align*}
  \Express[M]{\varepsilon}{\ms,\mo,\sigma,\tau} &= \langle\rangle \\
  \Express[M]{E}{\ms,\mo,\sigma,\tau} &= \langle \Express{E}{\ms,\mo,\sigma,\tau} \rangle \\
  \Express[M]{E^+, E}{\ms,\mo,\sigma,\tau} &= \Express[M]{E^+}{\ms,\mo,\sigma,\tau} : \Express{E}{\ms,\mo,\sigma,\tau}
\end{align*}
%
Hier is $E^+$ een meta-variabele voor elementen uit $\Exprs$.

\section{Statements}

\subsection{Basis}

Het evalueren van een statement noteren we met dubbele vishaken. Net als bij expressies hebben we ook hier extra informatie nodig in de vorm van $\ms$, $\mo$, $\sigma$ en $\tau$. Ook hier noteren we deze als subscript bij de haken. Onze uitspraken zijn dan van de vorm:
%
\begin{equation*}
  \Config{S}{\ms,\mo,\sigma,\tau} \longrightarrow (\ms',\mo').
\end{equation*}
%
Hiermee bedoelen we dat
%
\begin{equation*}
  \big(\,(S,\ms,\mo,\sigma,\tau), (\ms',\mo')\,\big) \in (\longrightarrow),
\end{equation*}
%
waarbij $\longrightarrow$ de volgende signatuur heeft 
%
\begin{equation*}
  (\longrightarrow) \subseteq (\Stm \times \MMs \times \MMo \times \II \times \II) \times (\MMs \times \MMo).
\end{equation*}
%
Deze transitie werkt op een statement $S\in\Stm$ in een toestand $(\ms,\mo)\in(\MMs,\MMo)$, waarbij ook bekend is wat het huidige bereik $\sigma \in \II$, en het huidige object $\tau \in (\II \cup \{\nil\})$ is. Het resultaat is een nieuwe toestand in de vorm van de twee geheugens $(\ms',\mo') \in (\MMs,\MMo)$.

Het huidige bereik verandert niet na executie van een programma, omdat bereik te maken heeft met de ordening van de code van het programma, welke niet verandert tijdens executie. Ook het huidige object verandert niet na executie, omdat de executie van een programma binnen een bepaald object uitvoering van een methode binnen dit object representeert. Het huidige bereik en huidig object geven dus de context van executie weer, maar niet de toestand van een programma.

Het kan zijn dat er geen huidig object is, dan is $\tau = \nil$. Dit is bijvoorbeeld van toepassing op de executie van de eerste regel van een programma, dat niet deel is van een andere programma (bijvoorbeeld de body van een functie).

Laten we beginnen met de simpelste constructie in onze taal, het lege statement $\SKIP$. Deze heeft de vorm van een axioma.
%
\begin{equation*}
  \Config{\SKIP}{\ms, \mo, \sigma, \tau}
  \longrightarrow
  (\ms, \mo)
  \tag*{[skip]}
\end{equation*}
%
$\SKIP$ verandert niets aan de toestand zodat $(\ms',\mo')=(\ms,\mo)$. Voor het samenstellen van statements hebben we de volgende regel nodig.
%
\begin{gather*}
  \frac{
    \Config{S_1}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo')
  \quad
    \Config{S_2}{\ms', \mo', \sigma, \tau}
    \longrightarrow
    (\ms'', \mo'')
  }
  {
    \Config{S_1; S_2}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms'', \mo'')
  }
  \tag*{[comp]}
\end{gather*}
%
Deze regel geeft aan dat het effect van twee sequentiele statements het gecombineerde effect is van de afzonderlijke, sequentiele, executie van beide statements.

Voor de controlestructuur $\IF$ hebben we twee regels nodig. De eerste is van toepassing als de boolse expressie en ware uitspraak over de huidige toestand van het programma representeerd, waarna het $\THEN$-deel moet worden uitgevoerd. De tweede als dit niet het geval is, waarna het $\ELSE$-deel moet worden uitgevoerd. Er moet dus aan een extra voorwaarde worden voldaan om deze regels toe te mogen passen. Dit zal vaker voorkomen bij de komende deductieregels. We noteren deze extra voorwaarden onder de regel of het axioma.
%
\begin{gather*}
  \frac{
    \Config{S_\text{then}}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo')
  }{
    \Config{\IF b \THEN  S_\text{then} \ELSE S_\text{else} }{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo')
  }
  \tag*{[if \#1]} \\
  \Desdas{
    \Desda[desda]{\Express[B]{b}{\ms, \mo,\sigma,\tau}}
  }
\end{gather*}
%
\begin{gather*}
  \frac{
    \Config{S_\text{else}}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo')
  }{
    \Config{\IF b \THEN  S_\text{then} \ELSE S_\text{else} }{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo')
  }
  \tag*{[if \#2]} \\
  \Desdas{
    \Desda[desda]{\neg \Express[B]{b}{\ms, \mo,\sigma,\tau}}
  }
\end{gather*}
%
Eenzelfde tactiek passen we toe bij een $\WHILE$-loop.
%
\begin{gather*}
  \frac{
    \Config{S_\text{while}}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms',\mo')
  \quad
    \Config{\WHILE b \DO S_\text{while} }{\ms', \mo', \sigma, \tau}
    \longrightarrow
    (\ms'',\mo'')
  }{
    \Config{\WHILE b \DO S_\text{while} }{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms'',\mo'')
  }
  \tag*{[while \#1]} \\
  \Desdas{
    \Desda[desda]{\Express[B]{b}{m,\sigma,\tau}}
  }
\end{gather*}
%
\begin{gather*}
  \Config{\WHILE b \DO S }{\ms, \mo, \sigma, \tau}
  \longrightarrow
  (\ms, \mo)
  \tag*{[while \#2]} \\
  \Desdas{
    \Desda[desda]{\neg \Express[B]{b}{\ms,\mo,\sigma,\tau}}
  }
\end{gather*}

\subsection{Variabelen}

We komen nu bij een interessanter deel van de taal, namelijk het \emph{declareren} van variabelen en het \emph{toekennen} van waarden. In deze sectie gaan we dus alleen de bereiken modificeren. Aan de basis hiervan ligt het declareren van een variabele met $\LOCAL$. We willen in het huidige bereik de eigen bindingen zó aanpassen, dat de \Id\ die we declareren gekoppeld wordt aan $\nil$ (de variabele bevat immers nog geen expliciete waarde). Voordat we dit kunnen doen, moeten we bereik $\sigma$ opzoeken in het geheugen voor bereiken $\ms$ met $\ms(\sigma)$. Vervolgens passen we de binding hiervan aan (zie notatie in §\ref{sec:bereiken} en §\ref{sec:uitbreiden}). Met de verwijzing naar het omliggend bereik $\pi$ doen we niks. Dit paar van uitgebreide bindingen en oud omliggend bereik zetten we terug in het geheugen $\ms$ op plek $\sigma$.
%
\begin{gather*}
  \Config{\LOCAL i}{\ms, \mo, \sigma, \tau}
  \longrightarrow
  (\ms', \mo)
  \tag*{[local]} \\
  \Desdas{
    \Desda{\ms' = \ms \surr{ \sigma \mapsto \big(b_{\ms(\sigma)}[i \mapsto \BOT], \pi_{\ms(\sigma)}\big) }}
  }
\end{gather*}
%
Wanneer we daadwerkelijk een waarde aan een variabele willen toekennen, doen we dit met dezelfde aanpassingstechniek als hierboven. Er is echter één groot verschil. Voordat we een waarde aan een variabele kunnen koppelen, moeten we eerst het bereik vinden waarin deze gedeclareerd is. Dit hoeft niet het huidige bereik te zijn en dus zoeken we deze op met de hulpfunctie $\Finds$. Daarnaast moeten we natuurlijk de expressie aan de rechter kant van het is-teken evalueren.
%
\begin{gather*}
  \Config{i = e}{\ms, \mo, \sigma, \tau}
  \longrightarrow
  (\ms', \mo)
  \tag*{[assign var]} \\
  \Desdas{
    \Desda[desda]{\Express{e}{\ms, \mo, \sigma, \tau} = v}
    \Desda{\sigma' = \Finds(\ms, \sigma, i)}
    \Desda{\ms'= \ms \surr{ \sigma' \mapsto \big(b_{\ms(\sigma')}[ i \mapsto v ], \pi_{\ms(\sigma')}\big) }}
  }
\end{gather*}

\subsection{Objecten}

Bij attributen gaat toekenning net iets anders. We hebben de hulp nodig van andere functies en we moeten rekening houden met het doorlopen van een pad. Daarnaast is er nog het speciale geval dat het eerste deel van het pad $\THIS$ is. Natuurlijk gebeuren al deze aanpassingen in het geheugen voor objecten $\mo$ in plaats van het geheugen voor bereiken $\ms$.
%
\begin{gather*}
  \Config{\THIS.p = e}{\ms, \mo, \sigma, \tau}
  \longrightarrow
  (\ms, \mo')
  \tag*{[assign this attr]} \\
  \Desdas{
    \Desda[desda]{\Express{e}{\ms, \mo, \sigma, \tau} = v}
    \Desda{\Trav(\mo, \tau, p) = (\omega, i)}
    \Desda{\mo'= \mo \surr{ \omega \mapsto \big(b_{\mo(\omega)}[ i \mapsto v ], \pi_{\mo(\omega)}\big) }}
  }
\end{gather*}
%
\begin{gather*}
  \Config{i.p = e}{\ms, \mo, \sigma, \tau}
  \longrightarrow
  (\ms', \mo)
  \tag*{[assign attr]} \\
  \Desdas{
    \Desda[desda]{\Express{e}{\ms, \mo, \sigma, \tau} = v}
    \Desda{\Express{i}{\ms,\sigma,\tau} = \omega}
    %\Desda{\sigma' = \Finds(\ms, \sigma, i)}
    %\Desda{b_{\ms(\sigma')}(i) = \omega \in \LL}
    \Desda{\Trav(\mo, \omega, p) = (\omega', j)}
    \Desda{\mo'= \mo \surr{ \omega' \mapsto \big(b_{\ms(\omega')}[ j \mapsto v ], \pi_{\ms(\omega')}\big) }}
  }
\end{gather*}

Nu hebben we nog niet bekeken hoe we aangeven dat een variabele een object bevat data. In §\ref{sec:waarden} is uitgebreid besproken dat er een significant verschil is tussen primitieve waarden en data. Toch gaat dit op bijna dezelfde manier als het toekennen van een primitieve waarde. De locatie $\omega$ van een object $o$ kan immers wel op dezelfde manier worden behandeld. Wat moet gebeuren is het aanmaken van een nieuw, leeg object in het geheugen voor objecten. Zo een leeg object heeft de vorm $(\varnothing, \nil)$. De bindingen zijn immers leeg en er is nog geen prototype gedefinieerd. Om een nieuwe plek in het geheugen te vinden, kijken we naar de lengte van het huidge geheugen. Tot slot voegen we het legen object achteraan het geheugen toe.
%
\begin{gather*}
  \AxiomC{$
    \Config{i \OBJECT}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms', \mo')
  $}
  {\DisplayProof}
  \tag*{[object]} \\
  \Desdas{
    \Desda[desda]{\Finds(\ms, \sigma, i) = \sigma'}
    \Desda{\omega = |\mo|}
    \Desda{\ms' = \ms \surr{ \sigma' \mapsto \big(b_{\ms(\sigma')}[i\mapsto \omega], \pi_{\ms(\sigma')}\big) }}
    \Desda{\mo' = \mo : (\varnothing,\nil)}
  }
\end{gather*}
%
Het definiëren van een prototype gaat met het $\CLONES$-statement. Hiervoor zoeken we simpelweg de locaties $\omega_i$ en $\omega_j$ van de twee objecten op. Vervolgens zetten we in het geheugen dat het prototype van het object in $\omega_i$ de locatie $\omega_j$ is.
%
\begin{gather*}
  \AxiomC{$
    \Config{i \CLONES j}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms, \mo')
  $}
  {\DisplayProof}
  \tag*{[clones]} \\
  \Desdas{
    \Desda[desda]{\Express{i}{\ms,\mo,\sigma,\tau} = \omega_i \in \II}
    \Desda{\Express{j}{\ms,\mo,\sigma,\tau} = \omega_j \in \II}
    \Desda{\mo' = \mo \surr{ \omega_i \mapsto \big(b_{\mo(\omega_i)}, \omega_j\big) }}
  }
\end{gather*}

\subsection{Functies}%TODO
%
\dots Komt nog \dots
%
\begin{gather*}
  \AxiomC{$
    \Config{S_{\!f}}{\ms', \mo, \sigma_{\!f\text{new}}, \omega'}
    \longrightarrow
    (\ms'', \mo'')
  $}
  \UnaryInfC{$
    \Config{i.s(e^*)}{\ms, \mo, \sigma, \tau}
    \longrightarrow
    (\ms'', \mo'')
  $}
  {\DisplayProof}
  \tag*{[call]} \\
  \Desdas{
    \Desda{\sigma_\text{def} = \Finds(\ms, \sigma, i)}
    \Desda{b_{\ms(\sigma_\text{def})}(i) = \omega \in \II}
    \Desda{\Trav(\mo, \omega, s) = (\omega', j)}
    \Desda{(S_{\!f}, I_{\!f}, i_{\!f}, \sigma_{\!f\text{def}}) = f = b_{\mo(\omega')}(j)}
    \Desda{\sigma_{\!f\text{new}} = \Nexts(\ms)}
    \Desda{\ms' = \ms\surr{ \sigma_{\!f\text{new}} \mapsto \big(\Surr{e^*}^*_{\ms,\sigma,\tau}(I_{\!f}), \sigma_{\!f\text{def}}\big) }}
  }
\end{gather*}

%\section*{Extra}

%Deze teksten zijn vooral bedoeld als “tekstvlees” (lorem ipsum's). We zullen axioma's en deductieregels introduceren waarmee we de relatie $(\longrightarrow)$ definiëren, die de volgende signatuur heeft:

%$$ (\longrightarrow) \subseteq (\Stm \times \MM \times \LL \times \LL) \times \MM $$

%Wanneer we een uitspraak doen van de vorm:

%$$ \Config{S}{m,\sigma,\tau} \longrightarrow m' $$

%..dan bedoelen we daarmee dat:

%$$ \big(\,(S,m,\sigma,\tau), m'\,\big) \in (\longrightarrow) $$

%Deze uitspraak moet je lezen als: “In de toestand met geheugen $m$, bereik $\sigma$ en \emph{this} object $\tau$, termineert het statement $S$, waarbij het resultaat-geheugen $m'$ is.”
%
%Een van deze axioma's [object], heeft betrekking tot de productieregel in de grammatica die de $\OBJECT$ “literal” introduceert.
%
%Wanneer bij een dergelijke opsomming van voorwaarden een nieuwe variabele wordt geïntroduceerd zoals hierboven, met de volgende vorm: $\textbf{desda } \square = \theta \dots$; dan moet deze gelezen worden als: $\textbf{desda } \exists_\theta \surr{ \square = \theta \dots }$.

% vim: syn=latex spell spl=nl cole=1
