<!DOCTYPE HTML>
<html>
<head>
  <title>Een natuurlijke semantiek voor prototype oververing en lexicaal bereik</title>
  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>

<h1>Een natuurlijke semantiek voor prototype oververing en lexicaal bereik</h1>
<p class="author">Kelley van Evert &amp; Tim Steenvoorden</p>

<div class="wrap">
  <h2>Inleiding</h2>In dit werkstuk presenteren we een natuurlijke semantiek die wij ontworpen hebben om de concepten <em>lexicaal bereik</em> en <em>prototype overerving</em> in object-geörienteerde talen te karakteriseren. Daartoe hebben we een minimale taal ontworpen die geïnspireerd is door de bestaande programmeertalen JavaScript en IO. JavaScript is een dynamische, prototype-gebaseerde taal die veelvuldig wordt gebruikt bij het ontwikkelen van internettoepassingen. Een opvallende functie van JavaScript is het gebruik van lexicaal bereik. IO is een onderzoekstaal door Steve Dekorte. Het belangrijkste kenmerk van deze taal is het prototype-gebaseerde object model.Lexicaal bereik (ook wel <em>static scoping</em> genaamd) en prototype overerving zijn mooie fenomenen. Ze zijn ook de fundamenten van &ldquo;The World's Most Misunderstood Programming Language&rdquo;: JavaScript. Maar lexicaal bereik ligt men eigenlijk heel natuurlijk: zo redeneren wiskundigen al meer dan honderd jaar met formules waarin variabelen lexicaal bereik hebben. En prototype overerving is slechts een elegant en simpel alternatief op klassieke overerving, wanneer het gaat om object-geörienteerd programmeren.Het doel van dit werkstuk is daarom een formele betekenis te geven aan deze concepten, maar dan wel zó dat de interpretatie van de formele uitspraken zo natuurlijk mogelijk en conceptueel verantwoord is. De bedoeling is dat men de gewoon Nederlandse interpretatie van een willekeurig axioma of deductieregel tegen zou kunnen komen in een college programmeren:\begin{multicols}{2}  \small  \raggedcolumns  \setlength{\columnseprule}{.5pt}  \scalebox{0.84}{\begin{minipage}{.25\textwidth}    \begin{NSAxiom}{object}      \begin{prooftree}        \AxiomC{$          \Config{i \OBJECT}{\ms, \mo, \sigma, \tau}          \longrightarrow          (\ms', \mo')        $}      \end{prooftree}      \begin{NSConditions}        \Cond{$ \textsc{Find}_\text{scope}(\ms, \sigma, i) = \sigma_\text{def} $}        \Cond{$ \omega = \textsc{Next}_\text{object}(\mo) $}        \Cond{$ \ms' = \ms \surr{ \sigma_\text{def} \mapsto \big(b_{\ms(\sigma')}[i\mapsto \omega], p_{\ms(\sigma')}\big) } $}        \Cond{$ \mo' = \mo \surr{ \omega \mapsto \big(\varnothing, \BOT\big) } $}      \end{NSConditions}    \end{NSAxiom}  \end{minipage}}    \columnbreak    \textit{&ldquo;Zoals jullie weten, moeten we bij statische scope eerst de definitie van de variabele zoeken in de huidige en daarna omliggende bereiken. Daarna maken we ruimte vrij in het geheugen en kan een nieuw object worden gemaakt. Een verwijzing naar dit object wordt vervolgens in de variabele gestopt&hellip;&rdquo;}\end{multicols}Na het bespreken van een aantal notationele keuzes en terminologie, presenteren we eerst de minimale taal, vervolgens het semantische model en tenslotte de natuurlijke semantiek die de twee voorgaande aan elkaar koppelt. In de case study die erop volgt proberen we een andere wiskundige aanpak te belichten om de semantiek te beschrijven.<h2>Notatie en terminologie</h2>In dit hoofdstuk behandelen we zowel een aantal gebruikelijke wiskundige concepten, als een aantal specifieke notaties en begrippen die in dit werkstuk vaak zullen terugkeren. Gezien het aard van het onderwerp zullen we bijvoorbeeld vaak over <em>eindige</em> functies en verzamelingen spreken.<h3>Functies</h3>In dit werkstuk identificeren we een functie met zijn grafiek, dit wil zeggen dat een functie $f : X \to Y$ wordt gedefiniëerd door de verzameling paren $(x, y) \in X \times Y$ waarvoor we beweren dat $f(x) = y$. Uiteraard voldoet zo'n verzameling $f \subseteq X \times Y$ aan de voorwaarde dat\begin{equation*}  \neg \exists_{x \in X,\, y_1 \in Y,\, y_2 \in Y} \surr{ (x, y_1) \in f \land (x, y_2) \in f \land y_1 \neq y_2 }\end{equation*}De reden voor deze aanpak is zeker niet fundamenteel: het is gewoonweg handig om $\varnothing$ te schrijven voor een nieuwe, &ldquo;lege&rdquo;, partiële functie.<h3>Partiële functies</h3>Vrijwel alle functies die we in dit werkstuk behandelen zijn partiële functies. Wanneer een partiële functie $f : X \to Y$ niet gedefiniëerd is op een zeker punt $x$ (dus $\neg \exists_{y \in Y} \surr { (x, y) \in f }$) schrijven we $f(x) = \bot$. Wanneer het omgekeerde het geval is, schrijven we $f(x) \neq \bot$, of kortweg $f(x) = y$ voor de gecombineerde uitspraak dat $f$ wél gedefiniëerd is op $x$ én dat $(x, y) \in f$.Voor een willekeurige term $\phi = &hellip; f(x)&hellip;$, waarbij $f$ een partiële functie is die niet gedefiniëerd is op punt $x$, geldt ook dat $\phi = \bot$. Op deze manier is het niet nodig om te schrijven: &ldquo;als $f(x) = \bot$, dan $z = \bot$; anders als $f(x) \neq \bot$, dan $z = \phi{BODY}rdquo;. Deze &ldquo;verkorte schrijfwijze&rdquo; stelt ons in staat om op een elegantie manier functie definities op te schrijven. Een voorbeeld:\begin{align*}  f : \NN \times \NN &\to \NN \\  f(0, 0) &= 1 \\  f(n, m + 1) &= f(n, m)\end{align*}In dit voorbeeld geldt voor alle $m \in \NN$ dat $f(0, m) = 1$, en voor alle $n \in \NN \setminus \{0\}$ is $f(n, m)$ niet gedefiniëerd.<h3>Eindige functies, eindige verzamelingen</h3>De reden dat de meeste behandelde functies partiëel zijn is omdat meeste onderdelen van ons semantisch model eindig van karakter zijn. Functies worden vaak gebruikt om &ldquo;een verzameling variabelen die een bepaalde waarde bevatten&rdquo; te representeren, bijvoorbeeld de gedefiniëerde variabelen in een zekere scope. Het zou ongewoon zijn om in een programmeertaal gebruik te maken van scopes waarin oneindig veel variabelen kunnen bestaan.Wanneer we het over een eindige functie $f$ hebben, bedoelen we daarmee dat het domein van die functie een eindige verzameling is. Dit kan worden uitgedrukt door te zeggen dat er een zeker getal $N \in \NN$ bestaat, zó dat $\underline{N}$ gelijkmachtig is aan het domein van $f$.\begin{multline*}  f : X \to Y \text{ is &ldquo;eindig&rdquo; } \DEF \\  \exists_{N \in \NN} \surr{ \text{er bestaat een bijectie van $\underline{N}$ naar } \{ x \in X \mid f(x) \neq \bot \} }\end{multline*}Hierbij is $\underline{N}$ gedefinieerd als de verzameling van de eerste $N$ natuurlijke getallen, ofwel $\{n \in \NN \mid n &lt; N\}$.We schrijven $\FiniteFunctions{Y}{X}$ voor de verzameling functies $\{f : X \to Y \mid f \text{ &ldquo;eindig&rdquo;} \}$.<h3>Functies uitbreiden</h3>\label{sec:uitbreiden}Het is vaak handig om een functie op een later tijdstip <em>uit te breiden</em>. Hiermee bedoelen we dat de functie ongewijzigd blijft op alle punten $(x, y) \in f$, behalve één specifiek punt $x_1$ dat we willen koppelen aan $y_1$ zodat geldt:\begin{equation*}  f(x_1) = y_1\end{equation*}Dit geven we aan in met de notatie:\begin{equation*}  f\surr{ x_1 \mapsto y_1 }\end{equation*}Wanneer we meerdere aanpassingen willen maken, bijvoorbeeld $x_2$ koppelen aan $y_2$ en $x_3$ aan $y_3$ kan dat met bovenstaande notatie als volgt\begin{equation*}  \big(f\surr{ x_2 \mapsto y_2 }\big)\surr{ x_3 \mapsto y_3 }\end{equation*}&hellip; hetgeen we afkorten tot:\begin{equation*}  f\surr{ x_2 \mapsto y_2, x_3 \mapsto y_3 }\end{equation*}Heel precies gezegd, als $f : X \to Y$ een functie is, $x_n \in X$ en $y_n \in Y$, dan:\begin{multline*}  f\surr{ x_n \mapsto y_n } \DEF f' \;\mathbf{desda} \\  \forall_{x \in X,\; y \in Y} \surr{ (x, y) \in f' \Leftrightarrow \big( (x, y) \in f \land x \neq x_n \big) \lor (x, y) = (x_n, y_n) }\end{multline*}<h3>Lijsten</h3>We zullen meermaals in ons werkstuk gebruik maken van willekeurig grote, maar altijd eindige, <em>lijsten</em> van elementen uit een zekere verzameling. Deze lijsten worden gerepresenteerd door eindige (partiële) functies $t : \NN \to X$ (met $X$ de verzameling waaruit we de elementen van de lijst nemen), waaraan nog een paar extra voorwaarden worden gesteld. De verzameling van alle lijsten op een zekere verzameling $X$, genoteerd $X_{\langle\rangle}$, is als volgt gedefiniëerd:\begin{equation*}X_{\langle\rangle} \DEF \big\{\, t : \NN \to X \mid \exists_{N \in \NN} \surr{ \forall_{n &lt; N}[t(n) \neq \bot] \land \forall_{n\ge N}[t(n) = \bot] } \,\big\}\end{equation*}We schrijven $\langle\rangle$, maar ook wel $\varnothing$ aangezien het gewoon een lege functie is zoals beschreven in het voorgaande, voor de lege lijst. Deze is natuurlijk altijd hetzelfde, ongeacht welke invulling wordt gekozen voor $X$.Als $t$ een zekere lijst is, dan zeggen we dat hij van <em>grootte</em> $N = \min\{n\in\NN \mid t(n) = \bot\}$ is.We schrijven $\langle x_0, x_1, &hellip;, x_{N-1}\rangle$ voor de lijst $t$ van grootte $N$ waarvoor geldt dat $\forall_{n &lt; N}[t(n) = x_n]$.Als $t$ een lijst is uit $X_{\langle\rangle}$, en $x$ een element van $X$, dan schrijven we $t:x$, de toevoeging van $x$ aan de lijst $t$, voor de lijst $t' = t[N \mapsto x]$, waarbij $N$ de grootte van $t$ is.<h3>Notationele conventies</h3>Terwille van leesbaarheid en elegantie houden we een aantal gebruikelijke notationele conventies aan.Veel wiskundige formules zijn van de vorm $t_1\; R\; t_2$, waarbij $R$ een zeker predikaat is (mogelijk $=$), en $t_1$ en $t_2$ termen. Dit soort formules zullen we wel vaker &ldquo;samenstellen&rdquo; tot formules als:\begin{gather*}  6 = 2 \cdot 3 &gt; 2 \ge 42 - 40 \\  f(x) = y \in Y\end{gather*}De intentie is enkel een elegante schrijfwijze te hanteren die makkelijk en intuïtief leest.Als we bovenstaande formules uitschrijven krijgen we:\begin{gather*}  6 = 2 \cdot 3 \land 2 \cdot 3 &gt; 2 \land 2 \ge 42 - 40 \\  f(x) = y \land y \in Y\end{gather*}<h2>Taal en syntaxis</h2>In dit hoofdstuk presenteren we de taal waarvoor we een natuurlijk semantiek construeren. De taal maakt gebruikt van prototype overerving en lexicaal bereik. Eerst beschouwen we een aantal voorbeeldprogramma's, om zo informeel de te formaliseren taal te karakteriseren. Daarna geven we een rigoureuze definitie met behulp van een \BNF\ grammatica.De structuur van de productieregels van deze grammatica worden in latere hoofdstukken gebruikt om axioma's en deductieregels op te stellen. Daarmee heeft de grammatica in zekere zin een dubbele functie.Het is belangrijk om te vermelden dat het hierbij niet gaat om een taal te maken die er &ldquo;mooi&rdquo; uit ziet. Het doel is om de essentiële onderdelen te verwerken die nodig zijn om lexicaal bereik en prototype overerving te formaliseren met een natuurlijke semantiek. Om dezelfde reden moet de syntaxis van de taal worden beschouwd als een mogelijke representatie van een <em>abstract syntax tree</em> van een &ldquo;echte&rdquo; programmeertaal. We zullen dan ook, waar mogelijk, puntkomma's en haakjes weglaten. Het gebruik van regeleindes en inspringen van blokken geeft, naar ons idee, binder belemmering bij het lezen van een programma.<h3>Voorbeeldprogramma's</h3>\label{sec:voorbeelden}Elk voorbeeldprogramma en zijn toelichtingen worden als volg gepresenteerd:\begin{NoBreak}\newCodeFragment[exa:template][Het eerste voorbeeldprogramma]\codeFragmentCaption\codeLines{  \codeLine{\VAR \id{f}}[$\id{f}$ moet eerst worden gedefiniëerd]  \codeLine{\id{f} = \FUN(i) \RETURNS \id{n}}  \codeLine{\IN \VAR \id{n}}  \codeLine{\IN \id{n} = 2 \times (\id{i} + 5)}  \codeLine{}[$\id{x}$ bestaat niet in deze scope]  \codeLine{\VAR \id{x}}[\id{x} heeft nog geen waarde, maar is wel gedefiniëerd]  \codeLine{\id{x} = \id{f}(42)}[\id{x} heeft nu de waarde 94]}\end{NoBreak}De toelichtingen moeten als informeel commentaar worden beschouwd, waarmee we aan proberen te geven hoe het programma zich gedraagt. Vaak zijn het uitspraken over de toestand waarin het programma zich bevindt, direct na de linker regel te hebben &ldquo;uitgevoerd&rdquo;.<h4>Basis</h4><h5>Declaratie van variabelen</h5>Een variabele moet altijd eerst worden gedeclareerd. Daarna kan er een waarde aan worden toegekend of kan het op andere manieren worden gebruikt. Een programma waarin variabelen worden gebruikt die nooit zijn gedefiniëerd is niet valide. In code fragment~\ref{exa:declaration} staat een voorbeeld van declaratie.\begin{NoBreak}\newCodeFragment[exa:declaration][Declaratie van variabelen]\codeFragmentCaption\codeLines{  \codeLine{}[\id{x} bestaat (nog) niet]  \codeLine{\VAR \id{x}}[\id{x} heeft nog geen waarde, maar is wel gedefiniëerd]  \codeLine{\id{x} = 5}[\id{x} bevat nu de waarde 5]}\end{NoBreak}Het concept van declaratie is juist in deze taal heel belangrijk, gezien het lexicaal bereik van variabelen. Wat lexicaal bereik precies inhoudt wordt weldra behandeld.<h5>Types</h5>\label{subsec:taal-types}Variabelen kunnen na declaratie waarden aannemen. Onze taal bevat waarden van drie types:\begin{itemize}  \item natuurlijk getal  \item functie  \item object\end{itemize}Het onderscheid tussen deze types wordt op <em>dynamisch</em> niveau gemaakt in plaats van op syntactisch niveau. Dat houdt in dat een willekeurige variabele elke willekeurige waarde kan aannemen, van elk willekeurig type. Ook kan het in zijn levensduur waarden van meerder types bevatten. Code fragment~\ref{exa:types} geeft dit weer.\begin{NoBreak}\newCodeFragment[exa:types][Waarden van verschillende types]\codeFragmentCaption\codeLines{  \codeLine{\VAR \id{x}}[declaratie zonder type indicatie]  \codeLine{\id{x} = 5}[type &ldquo;natuurlijk getal&rdquo;]  \codeLine{\id{x} = \FUN(\;)\{&hellip;\}}[type &ldquo;functie&rdquo;]  \codeLine{\id{x} \OBJECT}[type &ldquo;object&rdquo;, aan \id{x} kunnen nu attributen worden toegevoegd]  }\end{NoBreak}<h4>Lexicaal bereik</h4>Het <em>bereik</em> (ook wel <em>scope</em>) van een variabele, is dat deel van het programma waarin zij zichtbaar is. Er zijn verschillende manieren om dit bereik te definiëren. Een daarvan is <em>lexicaal bereik</em> (ook wel <em>lexical</em> of <em>static scoping</em>) dat expliciet gebruikt wordt door JavaScript.De vraag die we ons stellen is: &ldquo;Als ik de naam van een variabele tegen kom, over welke variabele heb ik het dan?&rdquo; Code fragmenten \ref{exa:zoek} en \ref{exa:zoek2} illustreren deze vraag. We zien dat het sleutelwoord \LOCAL\ hier een cruciale rol in speelt. De plaats waar een variabele gedeclareerd is, geeft zijn bereik aan. Wanneer een variabele niet in het lokale bereik is gedeclareerd, zoeken we die op in het <em>omliggende bereik</em>: het bereik dat lexicaal gezien om het locale bereik heen ligt.Door het nesten van bereiken ontstaat een <em>boomstructuur</em>. De niveaus van inspringing in onderstaande voorbeelden komt overeen met de boomstructuur van de bereiken.\begin{NoBreak}\newCodeFragment[exa:zoek][Zoek de definitie van variabele \id{x}]\codeFragmentCaption\codeLines{  \codeLine{\VAR \id{x}}[dit is de gezochte definitie van \id{x}]  \codeLine{\id{x} = 42}  \codeLine{}  \codeLine{\VAR \id{f}}  \codeLine{\id{f} = \FUN(\;)}  \codeLine{\IN &hellip; \id{x} &hellip;}[waar is deze \id{x} gedefiniëerd?]}\end{NoBreak}\begin{NoBreak}\newCodeFragment[exa:zoek2][Zoek de definitie van variabele \id{x}]\codeFragmentCaption\codeLines{  \codeLine{\VAR \id{x}}  \codeLine{\id{x} = 42}  \codeLine{}  \codeLine{\VAR \id{f}}  \codeLine{\id{f} = \FUN(\;)}  \codeLine{\IN \VAR \id{x}}[dit is de gezochte definitie van \id{x}]  \codeLine{\IN \id{x} = 43}  \codeLine{\IN &hellip; \id{x} &hellip;}[waar is deze \id{x} gedefiniëerd?]}\end{NoBreak}Een nieuw bereik ontstaat in onze taal enkel bij functie applicatie. Een functie op zich is een <em>primitieve waarde</em>, wat betekent dat er &ldquo;niks gebeurt&rdquo; als een functie wordt gedefiniëerd, net als er niks gebeurt wanneer je een getal aan een variabele toekent. Bij functie applicatie, echter, wordt een nieuw bereik aangemaakt, met als omliggend bereik het bereik waarin de functie was gedefiniëerd. Daarin wordt vervolgens de <em>body</em> van de functie uitgevoerd. In code fragment~\ref{exa:counting} wordt het belang van dit proces weergegeven: als nieuwe bereiken worden aangemaakt bij de definitie van functies, zou de uitvoer van $\id{d}(\;)$ 8 zijn in plaats van 43.\begin{NoBreak}\newCodeFragment[exa:counting][Het belang van creatie van bereiken bij functie applicatie]\codeFragmentCaption\codeLines{  \codeLine{\VAR \id{f}}  \codeLine{\id{f} = \FUN(n) \RETURNS \id{g}}  \codeLine{\IN \VAR \id{g}}  \codeLine{\IN \id{g} = \FUN(\;) \RETURNS \id{n}}  \codeLine{\IN \IN \id{n} = \id{n} + 1}  \codeLine{}  \codeLine{\VAR \id{c}}  \codeLine{\id{c} = \id{f}(5)}  \codeLine{\id{c}()}[de eerste aanroep $\id{c}(\;)$ levert eerst 6 op&hellip;]  \codeLine{\id{c}()}[de tweede aanroep $\id{c}(\;)$ levert daarna 7 op&hellip;]  \codeLine{}[]  \codeLine{\id{d} = \id{f}(42)}[$\id{d}(\;)$: 43, 44, 45, 46, &hellip;]}\end{NoBreak}<h4>Prototype overerving en object oriëntatie</h4>\label{sec:taal-prototypen}Prototype overerving is een variant van object-geörienteerd programmeren. De kern van object-geörienteerd programmeren is het concept van een <em>object</em>, dat ertoe dient een verschijnsel uit de werkelijkheid na te bootsen (een reëel object, een patroon, een abstract idee). Het doel is om meer te kunnen programmeren op een conceptueel niveau. Daarmee wordt bijvoorbeeld zowel creatie als onderhoud van de code makkelijker.Veel objecten zullen natuurlijk gelijke eigenschappen vertonen, of dezelfde structuur hebben. Verder wilt men concepten als specificering en generalisering toepassen op objecten. Deze problemen kunnen op meerdere manieren worden aangepakt. De bekendste variant is <em>klasse gebaseerde</em> object-oriëntatie (ook wel <em>klassieke object-oriëntatie</em>) en richt zich op het concept van een <em>klasse</em>. Objecten van een bepaalde klasse vertonen de structuur en gedrag van die klasse en heten <em>instanties</em>. Van specificering is sprake als een klasse eigenschappen van een andere klasse <em>overerft</em>. Klassieke object-oriëntatie vind men in talen als Java en C\#.Een andere aanpak met hetzelfde doel is <em>prototype gebaseerde</em> object-oriëntatie. Daarbij wordt geen scheiding gemaakt tussen de concepten klasse, die structuur en gedrag specificeert, en instantie, die enkel deze eigenschappen vertoont. In plaats daarvan wordt gewerkt met een prototype structuur, waarbij elk object naar een bepaald <em>prototype</em>-object refereert. Nu zijn objecten zelf de dragers van structuur en gedrag.Technisch gezien werkt prototype overerving als volgt. Van elk object is een prototype bekend, of het heeft geen prototype. Wanneer men een attribuut opvraagt van een zeker object, kan de op te leveren waarde procedureel als volgt worden opgevat:\begin{enumerate}  \item Bekijk of het attribuut gedefiniëerd is in het object zelf. In dat geval weten we de waarde en leveren deze op.  \item Anders zoeken we het attribuut op in het prototype van het object. Ook dan weten we de waarde en leveren deze op.  \item Wanneer ook het prototype het attribuut niet bevat, herhalen we de zoektocht voor alle volgende prototypen totdat we het attribuut hebben gevonden.\end{enumerate}Het grote verschil tussen object-gebaseerde talen en prototype-gebaseerde talen is dus dat de tweede geen onderscheid maakt tussen klassen en instanties. Een prototype heeft beide functies. Neem bijvoorbeeld het object \id{Deur}:\newCodeFragment\codeLines{  \codeLine{\VAR \id{Deur}}  \codeLine{\id{Deur} \OBJECT}}We declareren eerst een locale variabele die we vervolgens initialiseren als een object. Vanaf nu kunnen we \id{Deur} als instantie gebruiken door een attribuut te zetten:\codeLines{  \codeLine{\id{Deur}.\id{open} = 1}}Een \id{Deur} is standaard open. We kunnen \id{Deur} ook als een prototype gebruiken. In prototype-gebaseerde talen heet dit <em>klonen</em>:\codeLines{  \codeLine{\VAR \id{GeslotenDeur}}  \codeLine{\id{GeslotenDeur} \OBJECT}	\codeLine{\id{GeslotenDeur} \CLONES \id{Deur}}}\id{GeslotenDeur} heeft dan alle attributen van \id{Deur}:\codeLines{  \codeLine{\id{GeslotenDeur}.\id{open}}[waarde $\to$ 1]}Maar een \id{GeslotenDeur} moet natuurlijk gesloten zijn. We zetten zijn attribuut \id{open} op @0@:\codeLines{	\codeLine{\id{GeslotenDeur}.\id{open} = 0}}Een gewone \id{Deur} is nog steeds open:\codeLines{  \codeLine{\id{Deur}.\id{open}}[waarde $\to$ 1]}Attributen worden dus per object bewaard. Door \id{open} op @0@ te zetten in \id{GeslotenDeur} verandert er niks in \id{Deur}.We kunnen net zoveel klonen maken van een object als we willen en net zo diep klonen als we willen. Neem een \id{GlazenDeur}, dit is natuurlijk ook een \id{Deur}, maar wel doorzichtig:\codeLines{  \codeLine{\VAR \id{GlazenDeur}}  \codeLine{\id{GlazenDeur} \OBJECT}  \codeLine{\id{GlazenDeur} \CLONES \id{Deur}}  \codeLine{\id{GlazenDeur}.\id{doorzichtig} = 1}}Een gewone \id{Deur} heeft het attribuut \id{doorzichtig} niet, en dus een \id{GeslotenDeur} ook niet:\codeLines{  \codeLine{\id{GeslotenDeur}.\id{doorzichtig}}[fout!]}Maar we kunnen besluiten dat deuren standaard niet doorzichtig zijn:\codeLines{  \codeLine{\id{Deur}.\id{doorzichtig} = 0}}Zodat ook onze \id{GeslotenDeur} niet doorzichtig is:\codeLines{  \codeLine{\id{GeslotenDeur}.\id{doorzichtig}}[waarde $\to$ 0]}Maar er geld nog steeds:\codeLines{  \codeLine{\id{GlazenDeur}.\id{doorzichtig}}[waarde $\to$ 1]}We zien dat we met prototypes een zeer flexibele methode hebben om object-geörienteerd te programmeren. Het is niet nodig om de compiler of parser van te voren uit te leggen dat objecten aan bepaalde &ldquo;blauwdrukken&rdquo; moeten voldoen. We creëren objecten &ldquo;on-the-fly&rdquo;, alsmede hun attributen en relaties. Deze methode komt terug in talen als JavaScript, IO en Self.Natuurlijk is het ook mogelijk om <em>methoden</em> te definiëren. Dit zijn functie attributen gekoppeld aan een specifiek object. Stel dat we een \id{GeslotenDeur} graag open willen maken. We definiëren:\codeLines{  \codeLine{\id{GeslotenDeur}.\id{ontsluit} = \FUN (\id{poging})}  \codeLine{\IN \IF (\id{poging} = \THIS.\id{code}) \THEN}  \codeLine{\IN \IN \THIS.\id{open} = 1}  \codeLine{\IN \ELSE}  \codeLine{\IN \IN \THIS.\id{open} = 0}}\id{this} is hier een expliciete verwijzing naar het huidige object. Op dit moment kunnen we \id{ontsluit} nog niet aanroepen op \id{GeslotenDeur}:\codeLines{  \codeLine{\id{GeslotenDeur}.\id{ontsluit}(1234)}[fout!]}Het attribuut \id{code} is immers niet gedefinieerd in \id{GeslotenDeur} noch in zijn prototype \id{Deur}.We kunnen natuurlijk een \id{code} toekennen aan \id{GeslotenDeur}, maar laten we een specifieke \id{GeslotenDeur} maken met een \id{code}:\codeLines{  \codeLine{\VAR \id{Kluis}}  \codeLine{\id{Kluis} \OBJECT}  \codeLine{\id{Kluis} \CLONES \id{GeslotenDeur}}  \codeLine{\id{Kluis}.\id{code} = 4321}}Wanneer we de methode \id{ontsluit} aanroepen is deze niet gedefinieerd in \id{Kluis}, maar wel in zijn prototype \id{GeslotenDeur}. Die wordt dan uitgevoerd. Een belangrijke observatie is dat \id{ontsluit} wel wordt aangeroepen op \id{Kluis}. Dat betekent dat \id{this} verwijst naar \id{Kluis} en niet \id{GeslotenDeur}. Het attribuut \id{code} wordt dan wel gevonden:\codeLines{  \codeLine{\id{Kluis}.\id{ontsluit}(1234)}  \codeLine{\id{Kluis}.\id{open}}[waarde $\to$ 0]}Helaas was dat de verkeerde code, we proberen het nog een keer:\codeLines{  \codeLine{\id{Kluis}.\id{ontsluit}(1234)}  \codeLine{\id{Kluis}.\id{open}}[waarde $\to$ 1]}<h3>Formele definitie</h3>Nu volgt een formele definitie van de syntaxis van de taal, aan de hand van een \BNF\ grammatica. Getallen zijn als volgt gedefiniëerd:\begin{align*}  \Num \GrammarDef (0 \mid 1 \mid 2 \mid 3 \mid 4 \mid 5 \mid 6 \mid 7 \mid 8 \mid 9)^+\end{align*}Eigenlijk gebruiken we geen strikte \BNF, in deze specifieke gevallen, maar een hele simpele variant, zoals \textsc{e-bnf}, die ook reguliere expressies toelaat. Bovenstaand voorbeeld maakt dit duidelijk. Voorbeelden van elementen uit $\Num$ zijn &ldquo;0&rdquo;, &ldquo;1&rdquo;, &ldquo;235783&rdquo; en &ldquo;0003&rdquo;. Voorbeelden van elementen die niet in $\Num$ zitten zijn &ldquo;&rdquo;, &ldquo;-6&rdquo;, &ldquo;4.2&rdquo;.<em>Identifiers</em>, die gebruikt worden als namen voor variabelen en attributen, zijn op eenzelfde manier als volgt gedefiniëerd:\begin{align*}  \Id \GrammarDef (a \mid b \mid c \mid &hellip; \mid A \mid B \mid C \mid &hellip;)^+\end{align*}Hierbij moet men zich voorstellen dat alle letters uit het alfabet in de grammaticaregel staan op de voor de hand liggende manier.Het is soms ook nodig om meerdere komma-gescheiden namen te gebruiken, of een mogelijk lege lijst, zoals bij functie definities. Vandaar de volgende twee productieregels:\begin{align*}  \Ids \GrammarDef \Id \mid \Ids, \Id \\  \MaybeIds \GrammarDef \varepsilon \mid \Ids\end{align*}Een <em>pad</em> is een opeenvolging van \Ids\ gescheiden door punten en wordt gebruikt om ook naar attributen van objecten te kunnen refereren:\begin{align*}  \Path \GrammarDef \Id \mid \Id . \Path\end{align*}<em>Expressies</em>, die ofwel primitieve waarden (getallen en functies), ofwel objecten kunnen weergeven, en <em>boolse expressies</em>, die gebruikt worden voor loops en conditionele executie, definiëren we als volgt:\begin{align*}  \Expr \GrammarDef \Num \mid \Path \mid \Expr\; (+ \mid - \mid \times \mid /\,)\; \Expr \\  \GrammarOr \FUN\pmb{(}\,\MaybeIds\,\pmb{)}\; \GrammarOpt{\RETURNS \Id\;} \pmb{\{}\; \Stm\; \pmb{\}} \\  \Exprs \GrammarDef \Expr \mid \Exprs, \Expr \\  \MaybeExprs \GrammarDef \varepsilon \mid \Exprs \\  \BExpr \GrammarDef \TRUE \mid \FALSE \\  \GrammarOr \BExpr\; (\AND \mid \OR)\; \BExpr \\  \GrammarOr \NOT\; \BExpr \\  \GrammarOr \Expr\; (=\: \mid\: &lt;\: \mid\: \le\: \mid\: &gt;\: \mid\: \ge)\; \Expr\end{align*}De kern van de hele grammatica draait om de volgende productieregel voor <em>statements</em>. Een statement is een programma van goede vorm. Het betekent niet noodzakelijk dat het programma <em>valide</em> is, maar alle valide programma's zitten wel in $\Stm$. (Vanwege de focus van dit werkstuk definiëren we niet precies wanneer een programma valide is en wanneer niet.)\begin{align*}  \Stm \GrammarDef \SKIP \\  \GrammarOr \Stm; \Stm \\  \GrammarOr \IF \BExpr \THEN \Stm \ELSE \Stm \\  \GrammarOr \WHILE \BExpr \DO \Stm \\  \GrammarOr \LOCAL \Id \\  \GrammarOr \Id \OBJECT \\  \GrammarOr \Id \CLONES \Id \\  \GrammarOr \Path = \Expr \\  \GrammarOr \GrammarOpt{\Path =} \Id\,\pmb{(}\,\MaybeExprs\,\pmb{)}\end{align*}Merk op dat in delen van deze productieregel \Id's staan waar men misschien een \Path\ had verwacht. Zo zou het wenselijk lijken om bijvoorbeeld &ldquo;$\id{a}.\id{b} \CLONES \id{c}.\id{d}{BODY}rdquo; als een programma van goede vorm te beschouwen. Er zijn twee redenen waarom we dit niet hebben gedaan. Allereerst worden de axioma's en deductieregels ingewikkelder en daarmee minder elegant, of er zijn er meer nodig. Maar belangrijker nog: het is niet essentieel voor de taal. Voor elk programma zoals &ldquo;$\id{a}.\id{b} \CLONES \id{c}.\id{d}{BODY}rdquo;, bestaat er een equivalent programma zónder zulke paden:\begin{minipage}[t]{.5\textwidth}  \newCodeFragment  \codeLines{    \codeLine{\id{a}.\id{b} \CLONES \id{c}.\id{d}}  }\end{minipage}\begin{minipage}[t]{.5\textwidth}  \newCodeFragment  \codeLines{    \codeLine{\VAR x}    \codeLine{x = \id{a}.\id{b}}    \codeLine{}    \codeLine{\VAR y}    \codeLine{y = \id{c}.\id{d}}    \codeLine{}    \codeLine{x \CLONES y}  }\end{minipage}Hierin moeten $x$ en $y$ &ldquo;vers&rdquo; gekozen worden.<h2>Semantisch model</h2><h3>Bindingen</h3>\label{sec:bindingen}Aan de basis van ons model ligt het concept van een <em>binding</em>. Een binding is een toekenning van een <em>waarde</em> aan een variabele (een element uit de syntactische verzameling \Id). Bindingen zijn bijvoorbeeld van belang om de gedefiniëerd variabelen binnen een bereik vast te leggen, of de attributen van een bepaald object. Een <em>groep bindingen</em> is een eindige functie $b : \Id \to \VV$. De verzameling van alle groepen van bindingen definiëren we dus als\begin{equation*}  \BB \DEF \FiniteFunctions{\VV}{\Id}\end{equation*}We komen later terug op wat de waarden $\VV$ precies zijn in §\ref{sec:waarden}. Voor nu is het voldoende om te weten dat in ieder geval de natuurlijke getallen $\NN$ deel uitmaken van $\VV$.Bindingen komen veelvuldig terug in ons model. In bereiken worden <em>variabelen</em> gedeclareerd en aan waarden gekoppeld. Bij objecten zijn het de <em>attributen</em> die waarden krijgen toegekend.<h3>Bereik en omliggende bereiken</h3>\label{sec:bereiken}In sectie \ref{sec:voorbeelden} is informeel gebleken dat bereiken conceptueel goed te zien zijn als een boomstructuur. Stel we evalueren een variabele \id{x} in bereik $s$:\newCodeFragment\codeLines{  \codeLine{\id{x}}[We bevinden ons in een zeker bereik $s$.]}dan kunnen we dit als volgt uitleggen. Eerst zoeken we \id{x} op in de bindingen groep $b_s$, behorende bij bereik $s$.<h2>Natuurlijke Semantiek</h2><h3>Expressies</h3>&hellip; Komt nog &hellip;<h3>Statements</h3><h4>Basis</h4>Laten we beginnen met de simpelste constructie in onze taal, het lege statement \SKIP. Deze heeft de vorm van een axioma.\begin{NSAxiom}{skip}  \begin{prooftree}    \AxiomC{$      \Config{\SKIP}{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms, \mo)    $}  \end{prooftree}\end{NSAxiom}Zoals we kunnen zien zijn onze uitspraken van de vorm\begin{equation*}  \Config{S}{\ms,\mo,\sigma,\tau} \longrightarrow (\ms',\mo').\end{equation*}Hiermee bedoelen we dat\begin{equation*}\big(\,(S,\ms,\mo,\sigma,\tau), (\ms',\mo')\,\big) \in (\longrightarrow),\end{equation*}waarbij $\longrightarrow$ de volgende signatuur heeft \begin{equation*}  (\longrightarrow) \subseteq (\Stm \times \MMs \times \MMo \times \LLs \times \LLo) \times (\MMs \times \MMo).\end{equation*}Deze transitie werkt op een statement $S\in\Stm$ in een toestand $(\ms,\mo)\in(\MMs,\MMo)$ met als extra informatie de locatie van de huidige scope $\sigma\in\LLs$ en de locatie van het huidige \THIS-object $\tau\in\MMo$. Het resultaat is een nieuwe toestand in de vorm van de twee geheugens $(\ms',\mo')\in(\MMs,\MMo)$. \SKIP\ verandert niets aan de toestand zodat $(\ms',\mo')=(\ms,\mo)$.Voor het samenstellen van statements hebben we een regel nodig.\begin{NSAxiom}{comp}  \begin{prooftree}    \AxiomC{$      \Config{S_1}{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms', \mo')    $}    \AxiomC{$      \Config{S_2}{\ms', \mo', \sigma, \tau}      \longrightarrow      (\ms&rdquo;, \mo&rdquo;)    $}    \BinaryInfC{$      \Config{S_1; S_2}{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms&rdquo;, \mo&rdquo;)    $}  \end{prooftree}\end{NSAxiom}In dit geval geven we aan dat, wanneer we een een compositie hebben van de statements $S_1$ en $S_2$, we eerst $S_1$ uitvoerenen daarna $S_2$. Tijdens dit proces ontstaan nieuwe toestanden, waar we natuurlijk rekening mee moeten houden. De geheugens worden dan ook netjes doorgesluisd.Voor de controlestructuur \IF\ hebben we twee regels nodig. De eerste is voor het geval dat de \BExpr\ evalueert in \T, dan moet namelijk het statement van het \THEN-deel worden uitgevoerd. Wanneer de \BExpr\ evalueert in \F\ moet het \ELSE-deel worden uitgevoerd.Er moet dus aan een extra voorwaarde worden voldaan om deze regels toe te mogen passen. Dit zal vaker voorkomen bij de komende deductieregels. We noteren deze extra voorwaarden onder de regel of het axioma.\begin{NSAxiom}{if$^\T$}  \begin{prooftree}    \AxiomC{$      \Config{S_1}{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms', \mo')    $}    \UnaryInfC{$      \Config{\IF b \THEN  S_1 \ELSE S_2 }{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms', \mo')    $}  \end{prooftree}  \begin{NSConditions}    \Cond{$ \Surr{b}^\text{B}_{\ms, \mo,\sigma,\tau} = \T $}  \end{NSConditions}\end{NSAxiom}en:\begin{NSAxiom}{if$^\F$}  \begin{prooftree}    \AxiomC{$      \Config{S_2}{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms', \mo')    $}    \UnaryInfC{$      \Config{\IF b \THEN S_1 \ELSE S_2 }{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms', \mo')    $}  \end{prooftree}  \begin{NSConditions}    \Cond{$ \Surr{b}^\text{B}_{\ms, \mo,\sigma,\tau} = \F $}  \end{NSConditions}\end{NSAxiom}Eenzelfde tactiek passen we toe bij een \WHILE-loop.\begin{NSAxiom}{while$^\T$}  \begin{prooftree}    \AxiomC{$      \Config{S_1}{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms',\mo')    $}    \AxiomC{$      \Config{\WHILE b \DO S_1 }{\ms', \mo', \sigma, \tau}      \longrightarrow      (\ms&rdquo;,\mo&rdquo;)    $}    \BinaryInfC{$      \Config{\WHILE b \DO S_1 }{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms&rdquo;,\mo&rdquo;)    $}  \end{prooftree}  \begin{NSConditions}    \Cond{$ \Surr{b}^\text{B}_{m,\sigma,\tau} = \T $}  \end{NSConditions}\end{NSAxiom}en:\begin{NSAxiom}{while$^\F$}  \begin{prooftree}    \AxiomC{$      \Config{\WHILE b \DO S_1 }{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms, \mo)    $}  \end{prooftree}  \begin{NSConditions}    \Cond{$ \Surr{b}^\text{B}_{\ms,\mo,\sigma,\tau} = \F $}  \end{NSConditions}\end{NSAxiom}<h4>Variabelen</h4>We komen nu bij een interessanter deel van de taal, namelijk het <em>declareren</em> van variabelen en het <em>toekennen</em> van waarden. In deze sectie gaan we dus alleen de bereiken modificeren. Aan de basis hiervan ligt het declareren van een variabele met \LOCAL. We willen in het huidige bereik de eigen bindingen zó aanpassen, dat de \Id\ die we declareren gekoppeld wordt aan $\nil$ (de variabele bevat immers nog geen expliciete waarde). Voordat we dit kunnen doen, moeten we bereik $\sigma$ opzoeken in het geheugen voor bereiken $\ms$ met $\ms(\sigma)$. Vervolgens passen we de binding hiervan aan (zie notatie in §\ref{sec:bereiken} en §\ref{sec:uitbreiden}). Met de verwijzing naar het omliggend bereik $\pi$ doen we niks. Dit paar van uitgebreide bindingen en oud omliggend bereik zetten we terug in het geheugen $\ms$ op plek $\sigma$.\begin{NSAxiom}{declare}  \begin{prooftree}    \AxiomC{$      \Config{\VAR i}{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms', \mo)    $}  \end{prooftree}  \begin{NSConditions}    \Cond{$ \ms' = \ms \surr{ \sigma \mapsto \big(b_{\ms(\sigma)}[i \mapsto \BOT], p_{\ms(\sigma)}\big) } $}  \end{NSConditions}\end{NSAxiom}Wanneer we daadwerkelijk een waarde aan een variabele willen toekennen, doen we dit met dezelfde aanpassingstechniek als hierboven. Er is echter één groot verschil. Voordat we een waarde aan een variabele kunnen koppelen, moeten we eerst het bereik vinden waarin deze gedeclareerd is. Dit hoeft niet het huidige bereik te zijn en dus zoeken we deze op met de hulpfunctie $\textsc{Find}_\text{scope}$. Daarnaast moeten we natuurlijk de expressie aan de rechter kant van het is-teken evalueren.\begin{NSAxiom}{assign$^\text{i}$}  \begin{prooftree}    \AxiomC{$      \Config{i = e}{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms', \mo)    $}  \end{prooftree}  \begin{NSConditions}    \Cond{$ \sigma_\text{def} = \textsc{Find}_\text{scope}(\ms, \sigma, i) $}    \Cond{$ \Surr{e}_{\ms, \mo, \sigma, \tau} = v $}    \Cond{$ \ms'= \ms \surr{ \sigma_\text{def} \mapsto \big(b_{\ms(\sigma_\text{def})}[ i \mapsto v ], p_{\ms(\sigma_\text{def})}\big) } $}  \end{NSConditions}\end{NSAxiom}<h4>Objecten</h4>Bij attributen gaat toekenning net iets anders. We hebben de hulp nodig van andere functies en we moeten rekening houden met het doorlopen van een pad. Daarnaast is er nog het speciale geval dat het eerste deel van het pad \THIS\ is. Natuurlijk gebeuren al deze aanpassingen in het geheugen voor objecten $\mo$ en gebruiken we locaties van objecten $\omega\in\LLo$ in plaats van locaties van bereiken.\begin{NSAxiom}{assign$^\text{slot}$}  \begin{prooftree}    \AxiomC{$      \Config{i.s = e}{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms', \mo)    $}  \end{prooftree}  \begin{NSConditions}    \Cond{$ \sigma_\text{def} = \textsc{Find}_\text{scope}(\ms, \sigma, i) $}    \Cond{$ b_{\ms(\sigma_\text{def})}(i) = \omega \in \LL $}    \Cond{$ \textsc{Trav}(\mo, \omega, s) = (\omega', j) $}    \Cond{$ \Surr{e}_{\ms, \mo, \sigma, \tau} = v $}    \Cond{$ \ms'= \ms \surr{ \omega' \mapsto \big(b_{\ms(\omega')}[ j \mapsto v ], p_{\ms(\omega')}\big) } $}  \end{NSConditions}\end{NSAxiom}\begin{NSAxiom}{assign$^\text{this}$}  \begin{prooftree}    \AxiomC{$      \Config{\THIS.s = e}{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms, \mo')    $}  \end{prooftree}  \begin{NSConditions}    \Cond{$ \textsc{Trav}(\mo, \tau, s) = (\omega, i) $}    \Cond{$ \Surr{e}_{\ms, \mo, \sigma, \tau} = v $}    \Cond{$ \mo'= \mo \surr{ \omega \mapsto \big(b_{\mo(\omega)}[ i \mapsto v ], p_{\mo(\omega)}\big) } $}  \end{NSConditions}\end{NSAxiom}Nu hebben we nog niet bekeken hoe we aangeven dat een variabele een object bevat. In §\ref{sec:waarden} is uitgebreid besproken dat er een significant verschil is tussen primitieve waarden en objecten. Toch gaat dit op bijna dezelfde manier als het toekennen van een primitieve waarde. De locatie $\omega$ van een object $o$ kan immers wel op dezelfde manier worden behandeld. Wat wel moet gebeuren is het aanmaken van een nieuw, leeg object in het geheugen voor objecten. Zo een leeg object heeft de vorm $(\varnothing, \nil)$. De bindingen zijn immers leeg en er is nog geen prototype gedefinieerd.\begin{NSAxiom}{object}  \begin{prooftree}    \AxiomC{$      \Config{i \OBJECT}{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms', \mo')    $}  \end{prooftree}  \begin{NSConditions}    \Cond{$ \textsc{Find}_\text{scope}(\ms, \sigma, i) = \sigma_\text{def} $}    \Cond{$ \omega = \textsc{Next}_\text{object}(\mo) $}    \Cond{$ \ms' = \ms \surr{ \sigma_\text{def} \mapsto \big(b_{\ms(\sigma')}[i\mapsto \omega], p_{\ms(\sigma')}\big) } $}    \Cond{$ \mo' = \mo \surr{ \omega \mapsto \big(\varnothing, \BOT\big) } $}  \end{NSConditions}\end{NSAxiom}Het definiëren van een prototype gaat met het \CLONES-statement. Hiervoor zoeken we simpelweg de locaties $\omega_i$ en $\omega_j$ van de twee objecten op. Vervolgens zetten we in het geheugen dat het prototype van het object in $\omega_i$ de locatie $\omega_j$ is.\begin{NSAxiom}{clones}  \begin{prooftree}    \AxiomC{$      \Config{i \CLONES j}{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms, \mo')    $}  \end{prooftree}  \begin{NSConditions}    \Cond{$ \Surr{i}_{\ms,\mo,\sigma,\tau} = \omega_i \in \LL $}    \Cond{$ \Surr{j}_{\ms,\mo,\sigma,\tau} = \omega_j \in \LL $}    \Cond{$ \mo' = \mo \surr{ \omega_i \mapsto \big(b_{\mo(\omega_i)}, \omega_j\big) } $}  \end{NSConditions}\end{NSAxiom}<h4>Functies</h4>&hellip; Komt nog &hellip;\begin{NSAxiom}{call}  \begin{prooftree}    \AxiomC{$      \Config{S_{\!f}}{\ms', \mo, \sigma_{\!f\text{new}}, \omega'}      \longrightarrow      (\ms&rdquo;, \mo&rdquo;)    $}    \UnaryInfC{$      \Config{i.s(e^*)}{\ms, \mo, \sigma, \tau}      \longrightarrow      (\ms&rdquo;, \mo&rdquo;)    $}  \end{prooftree}  \begin{NSConditions}    \Cond{$ \sigma_\text{def} = \textsc{Find}_\text{scope}(\ms, \sigma, i) $}    \Cond{$ b_{\ms(\sigma_\text{def})}(i) = \omega \in \LL $}    \Cond{$ \textsc{Trav}(\mo, \omega, s) = (\omega', j) $}    \Cond{$ (S_{\!f}, I_{\!f}, i_{\!f}, \sigma_{\!f\text{def}}) = f = b_{\mo(\omega')}(j) $}    \Cond{$ \sigma_{\!f\text{new}} = \textsc{Next}_\text{scope}(\ms) $}    \Cond{$ \ms' = \ms\surr{ \sigma_{\!f\text{new}} \mapsto \big(\Surr{e^*}^*_{\ms,\sigma,\tau}(I_{\!f}), \sigma_{\!f\text{def}}\big) } $}  \end{NSConditions}\end{NSAxiom}
</div>

<div class="bottom"></div>

<!--
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [
        ['$','$']
      ]
    }
  });
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
-->
</body>
</html>