\documentclass[11pt,oneside,parskip=half]{scrbook}
\usepackage[a4paper]{geometry}

\usepackage{fontspec}
%\setmainfont{Century Schoolbook L}
\setmainfont[
  SmallCapsFont={Linux Libertine O},
  SmallCapsFeatures={Letters=SmallCaps},
  Mapping=tex-text,
  Ligatures={TeX, Common}
]{Linux Libertine O}
\setmonofont[Scale=0.85]{Bera Sans Mono}
%\setmonofont{Consolas}

\usepackage{amsmath}
\usepackage{unicode-math}
\setmathfont{Asana Math}% de [] haakjes zijn wat groot, maar \mathbb{N} etc is mooier dan in XITS Math
%\setmathfont{XITS Math}

\usepackage{xunicode}

%\renewcommand{\textsc}[1]{\addfontfeature{Letters=SmallCaps} #1}

\usepackage{polyglossia}
\setdefaultlanguage{dutch}

\usepackage{tabularx}% tables: equal width columns
\usepackage{multirow}% tables: rowspan
\usepackage{booktabs}% tables: \toprule, \bottomrule, ...
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{xargs}
\usepackage{enumitem}
\usepackage{float}
\usepackage{ifthen}
\usepackage[font=small,it]{caption}
\usepackage{environ}
\usepackage{multicol}
\usepackage{setspace} \setstretch{1.1} %\doublespacing

\usepackage{bussproofs}
\def\extraVskip{4pt} % Iets meer verticale ruimte
% De volgende commands gebruik ik om op een simpele manier (1) de toegepaste regel aan de rechterkant van de deductieregel te laten zien, en (2) een automatische nummering aan de linkerkant te laten zien.
% Normaal gesproken gebruik je \RightLabel en \LeftLabel, maar nu gebruik ik dus: \Label (enkel een label) en \CountedLabel (label en automatische nummering)
% Terugzetten op 1 kan met "\setcounter{theLabel}{1}", bijvoorbeeld bij een nieuwe boom
\newcounter{theLabel}
\setcounter{theLabel}{1}
\newcommand{\Label}[1]{
  \RightLabel{\small #1}
}
\newcommand{\CountedLabel}[1]{
  \RightLabel{\small #1}
  \LeftLabel{\scriptsize \arabic{theLabel}}
  \addtocounter{theLabel}{1}
}

\newcommand{\newmathcommand}[2]
  {\newcommand{#1}
    {\ensuremath{#2}}}
\newcommand{\newkeyword}[2]
  {\newcommand{#1}
    {\text{\small\ttfamily\bfseries #2}}}
\newcommand{\newconstant}[2]
  {\newkeyword{#1}{#2}}
  %{\newcommand{#1}
     %{\text{\small\ttfamily\scshape #2}}}
\newcommand{\newnonterminal}[2]
  {\newcommand{#1}
    {\textit{#2}}}
\newcommand{\newset}[1]
  {\expandafter\newcommand\expandafter{\csname #1#1\endcsname}
    {\ensuremath{\mathbb{#1}}}}
\newcommand{\renewset}[1]
  {\expandafter\renewcommand\expandafter{\csname #1#1\endcsname}
    {\ensuremath{\mathbb{#1}}}}
\newcommand{\newBool}[1]
  {\expandafter\newcommand\expandafter{\csname b#1\endcsname}
    {\ensuremath{\mathbf{#1}}}}

\newcommand{\id}[1]
  {\text{\ttfamily\small\upshape #1}}

\newcommand{\surrAngle}[1]
  {\ensuremath{\big<\,#1\,\big>}}
\newcommand{\SurrAngle}[1]
  {\ensuremath{\big<\!\big<\,#1\,\big>\!\big>}}
\newcommand{\surr}[1]
  {\ensuremath{\big[\,#1\,\big]}}
\newcommand{\Surr}[1]
  {\ensuremath{\big[\!\big[\,#1\,\big]\!\big]}}

% Expression: " T [[E]] \sigma, tau "
\newcommand{\Express}[3][]
  {\Surr{#2}^\text{#1}_{#3}}

% Configuration: " <<S>> m, \sigma, \tau "
%\newcommand{\Config}[2]
  %{\left<#1, #2\right>}%  -- <S,m,s,t>
%\newcommand{\Config}[2]
  %{\surr{#1}_{#2}}%       -- [S]m,s,t
%\newcommand{\Config}[2]
  %{\surrAngle{#1}_{#2}}%  -- <S>m,s,t
\newcommand{\Config}[2]
  {\SurrAngle{#1}_{#2}}%  -- <<S>>m,s,t

% Functions:
\newmathcommand{\Trav}
  {\textsc{Trav}}
\newmathcommand{\Finds}
  {\textsc{Find}_\text{scope}}
\newmathcommand{\Findo}
  {\textsc{Find}_\text{proto}}
\newmathcommand{\Findp}
  {\textsc{Find}_\text{proto}}
\newmathcommand{\Nexts}
  {\textsc{Next}_\text{scope}}
\newmathcommand{\Nexto}
  {\textsc{Next}_\text{object}}

\newcommand{\desda}
  {\textbf{desda }}
\newcommand{\anders}
  {\textbf{anders }}
\newcommand{\nil}
  {\rotatebox{90}{$\Vdash$}}
\let\BOT\nil

\newcommand{\defineNewKeyword}[2]{%
  \DeclareMathOperator{#1}{\ensuremath{\text{\small\ttfamily\bfseries #2}}}
}

\newcommand{\COMP}{;\;}

\defineNewKeyword{\LOCAL}{local}
\defineNewKeyword{\CLONES}{clones}
\defineNewKeyword{\OBJECT}{object}
\defineNewKeyword{\FUN}{function}
\defineNewKeyword{\RETURNS}{returns}
\defineNewKeyword{\SKIP}{skip}
\defineNewKeyword{\IF}{if}
\defineNewKeyword{\THEN}{then}
\defineNewKeyword{\ELSE}{else}
\defineNewKeyword{\WHILE}{while}
\defineNewKeyword{\DO}{do}
\defineNewKeyword{\END}{end}

\defineNewKeyword{\AND}{and}
\defineNewKeyword{\OR}{or}
\defineNewKeyword{\NOT}{not}

\newconstant{\TRUE}{true}
\newconstant{\FALSE}{false}
\newconstant{\SELF}{self}
\newconstant{\THIS}{this}
\newconstant{\PROTO}{proto}

%\newconstant{\AND}{\;and\;}
%\newconstant{\OR}{\;or\;}
%\newconstant{\NOT}{\;not\;}

\newnonterminal{\Stm}{Statement}
\newnonterminal{\Id}{Identifier}
\newnonterminal{\Ids}{Identifiers}
\newnonterminal{\MaybeIds}{MaybeIdentifiers}
\newnonterminal{\Path}{Path}
\newnonterminal{\Expr}{Expression}
\newnonterminal{\Exprs}{Expressions}
\newnonterminal{\MaybeExprs}{MaybeExpressions}
\newnonterminal{\BExpr}{BooleanExpression}
\newnonterminal{\Num}{Number}

\renewset{S}
\newset{O}
\newset{B}
\newset{M}
\newset{L}
\newset{F}
\newset{V}
\newset{N}
\newset{Z}
\newset{I}

\newBool{T}
\newBool{F}

\newmathcommand{\LLs}
  {\LL_{\text{s}}}
\newmathcommand{\LLo}
  {\LL_{\text{o}}}
\newmathcommand{\MMs}
  {\MM_{\text{s}}}
\newmathcommand{\MMo}
  {\MM_{\text{o}}}

\newmathcommand{\ms}
  {m_{\text{s}}}
\newmathcommand{\mo}
  {m_{\text{o}}}

\newcommand{\BNF}
  {\textsc{bnf}}

\def\GrammarDef{::=\;&}
\def\GrammarOr{\mid\;&}
\newcommand{\GrammarOpt}[1]{[#1]\;}

\def\IN{\quad}

\newcommand{\<}
  {\ensuremath{\langle}}
\renewcommand{\>}
  {\ensuremath{\rangle}}

\frenchspacing% Cruciaal!
\raggedbottom% Handig

\floatstyle{plain}
\newfloat{code}{H}{code.list.aux}[chapter]
\floatname{code}{Code fragment}

\newcounter{CodeFragment}[chapter]
\renewcommand{\theCodeFragment}{\thechapter.\arabic{CodeFragment}}
\NewEnviron{CodeFragment}[1][]{%
  \refstepcounter{CodeFragment}%
  %\setcounter{CodeFragmentLineNo}{0}%
  \vspace{-1pc}%
  \begin{code}
    \ifthenelse{\equal{#1}{}}{\caption{}}{\caption{#1}}%
	  \begin{equation*}%
		  \begin{array}{l@{\hspace*{.02\textwidth}}|@{\hspace*{.02\textwidth}}l}%
		  \hspace*{.35\textwidth} & \hspace*{.55\textwidth} \\[-1pc]%
		  \BODY%
		  \end{array}%
	  \end{equation*}%
	  \vspace{-1pc}%
	\end{code}%
  \vspace{-1pc}%
}

\newcounter{CodeFragmentLineNo}[CodeFragment]
\newcommand{\Line}[2]{%
  \refstepcounter{CodeFragmentLineNo}%
  \text{\color{gray} \scriptsize \arabic{CodeFragmentLineNo}}\;\;%
  #1 &%
  \ifthenelse{\equal{#2}{}}{}{\textit{\small- #2}}%
  \\
}

% todo if second param empty? then don't display scalebox etc..
\newcommand{\AxiomOrInference}[2]{%
  \renewcommand{\arraystretch}{1.2}%
  \begin{minipage}{\textwidth}% prevent page break
    #1% = \begin{prooftree} ... \end{prooftree}
    \vspace*{-.5pc}%
    \hspace*{.45\textwidth}% ideally: .5\textwidth - 1/2 "desda\quad"
    \scalebox{.85}{%
      #2%
    }%
  \end{minipage}%
}

\NewEnviron{NSAxiom}[1]{%
  \renewcommand{\arraystretch}{1.2}%
  \begin{minipage}{\textwidth}% prevent page break
  \BODY%
  \end{minipage}%
}
\NewEnviron{NSConditions}{%
  \vspace*{-.5pc}%
  \hspace*{.45\textwidth}% ideally: .5\textwidth - 1/2 "desda\quad"
  \scalebox{.85}{%
    \begin{tabular}{@{}r@{\quad}l@{}}%@
      \textbf{desda} \BODY%
    \end{tabular}%
  }%
}
\newcommand{\Cond}[1]{%
  & #1 \\
}

\newcommand{\FiniteFunctions}[2]{\ensuremath{\text{eindige }{#1}^{#2}}}

\def\DEF{\buildrel{\text{def}}\over{=}}
\def\Proto{\sqsubset^p}
\def\Outer{\sqsubset^s}
\def\ProtoEq{\sqsubseteq^p}
\def\OuterEq{\sqsubseteq^s}
\def\Attr{\textit{attr}}
\def\SDef{\textit{def}}
\newcommand{\ScopeID}[1]{\ensuremath{(1, #1)}}
\newcommand{\ObjectID}[1]{\ensuremath{(2, #1)}}

\title{Een natuurlijke semantiek voor prototype oververing en lexicaal bereik}
\author{Kelley van Evert \& Tim Steenvoorden}

% Code fragments
% Usage:
%   \newCodeFragment[fraglabel][caption]
%   \codeFragmentCaption
%   \codeLines{
%     \codeLine           {\LOCAL f}
%     \codeLine[linelabel]{\LOCAL f}
%     \codeLine           {\LOCAL f}[comment]
%     \codeLine[linelabel]{\LOCAL f}[comment]
%   }
%   \codeLines{
%     \codeLine{\LOCAL f}
%   }
%   \ref{fraglabel} -- e.g. "3.1" for the first code fragment in chapter 3
%   \ref{linelabel} -- e.g. "6" for the sixth line in the code fragment
\newcounter{ncode}[chapter]
\renewcommand{\thencode}{\thechapter.\arabic{ncode}}
% FIXME: caption kan op vorige pagina blijven staan
\newcommand{\theCodeFragmentCaption}{}
\newcounter{codeline}[ncode]
\newcommandx{\newCodeFragment}[2][1=,2=]{% args: [1] label; [2] title = caption
  \refstepcounter{ncode}%
  \ifthenelse{\equal{#1}{}}{}{\label{#1}}%
  \renewcommand{\theCodeFragmentCaption}{#2}%
}
\newcommand{\codeFragmentCaption}{%
  ~\centerline{\small%
    \textit{Code fragment \thencode}%
    \ifthenelse{\equal{\theCodeFragmentCaption}{}}%
    {}%
    {. \theCodeFragmentCaption}%
  }~%
  \\[-1.6pc]%
}
\NewEnviron{codelines}{%
  \par
  \vspace{4pt}%
  \begin{tabular}{@{~~}r@{~}!{\color{black!70} \vrule width 1.5pt}@{~~}l@{~~}l@{}}%
    \BODY%
  \end{tabular}%
  \vspace{4pt}%
  \par
}
\newcommand{\codeLines}[1]{%
  \par
  \vspace{4pt}%
  \begin{tabular}{@{~~}r@{~}!{\color{black!70} \vrule width 1.5pt}@{~~}l@{~~}l@{}}%
    #1%
  \end{tabular}%
  \vspace{4pt}%
  \par
}
\newcommandx{\codeLine}[3][1=,3=]{% args: [1] label; [2] code (math); [3] comment
  \refstepcounter{codeline}%
  \ifthenelse{\equal{#1}{}}{}{\label{#1}}%
  \lineNum{\thecodeline} &%
  $ #2 $ &%
  \ifthenelse{\equal{#3}{}}{}{\lineComment{#3}} \\[-1pt]%
}
\newcommand{\lineNum}[1]{%
  {\color{black!50}\scriptsize #1}%
}
\newcommand{\lineComment}[1]{%
  \textit{--- \small #1}%
}

\newlength{\NoBreakCurrentParskip}
\NewEnviron{NoBreak}{%
  \setlength{\NoBreakCurrentParskip}{\parskip}%
  \begin{minipage}{\textwidth}%
    \setlength{\parskip}{\NoBreakCurrentParskip}%
    \BODY
  \end{minipage}%
}

\NewEnviron{htmlskip}{\BODY}
\newcommand{\htmlinsert}[1]{}

\begin{document}

\maketitle

\frontmatter

\tableofcontents

\input inleiding.chapter

\mainmatter

\input notatie-en-terminologie.chapter
\input taal-en-syntax.chapter
\input semantisch-model.chapter
\input natuurlijke-semantiek.chapter
%\input case-study.chapter

\backmatter

\end{document}

% vim: syn=latex spell spl=nl cole=1 cocu=nv
